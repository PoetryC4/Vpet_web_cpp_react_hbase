/**
 * Autogenerated by Thrift Compiler (0.9.2)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "hbase_types.h"

#include <algorithm>
#include <ostream>

#include <thrift/TToString.h>

namespace apache { namespace hadoop { namespace hbase { namespace thrift2 {

int _kTDeleteTypeValues[] = {
  TDeleteType::DELETE_COLUMN,
  TDeleteType::DELETE_COLUMNS,
  TDeleteType::DELETE_FAMILY,
  TDeleteType::DELETE_FAMILY_VERSION
};
const char* _kTDeleteTypeNames[] = {
  "DELETE_COLUMN",
  "DELETE_COLUMNS",
  "DELETE_FAMILY",
  "DELETE_FAMILY_VERSION"
};
const std::map<int, const char*> _TDeleteType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(4, _kTDeleteTypeValues, _kTDeleteTypeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kTDurabilityValues[] = {
  TDurability::USE_DEFAULT,
  TDurability::SKIP_WAL,
  TDurability::ASYNC_WAL,
  TDurability::SYNC_WAL,
  TDurability::FSYNC_WAL
};
const char* _kTDurabilityNames[] = {
  "USE_DEFAULT",
  "SKIP_WAL",
  "ASYNC_WAL",
  "SYNC_WAL",
  "FSYNC_WAL"
};
const std::map<int, const char*> _TDurability_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(5, _kTDurabilityValues, _kTDurabilityNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kTConsistencyValues[] = {
  TConsistency::STRONG,
  TConsistency::TIMELINE
};
const char* _kTConsistencyNames[] = {
  "STRONG",
  "TIMELINE"
};
const std::map<int, const char*> _TConsistency_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(2, _kTConsistencyValues, _kTConsistencyNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kTReadTypeValues[] = {
  TReadType::DEFAULT,
  TReadType::STREAM,
  TReadType::PREAD
};
const char* _kTReadTypeNames[] = {
  "DEFAULT",
  "STREAM",
  "PREAD"
};
const std::map<int, const char*> _TReadType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(3, _kTReadTypeValues, _kTReadTypeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kTCompareOpValues[] = {
  TCompareOp::LESS,
  TCompareOp::LESS_OR_EQUAL,
  TCompareOp::EQUAL,
  TCompareOp::NOT_EQUAL,
  TCompareOp::GREATER_OR_EQUAL,
  TCompareOp::GREATER,
  TCompareOp::NO_OP
};
const char* _kTCompareOpNames[] = {
  "LESS",
  "LESS_OR_EQUAL",
  "EQUAL",
  "NOT_EQUAL",
  "GREATER_OR_EQUAL",
  "GREATER",
  "NO_OP"
};
const std::map<int, const char*> _TCompareOp_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(7, _kTCompareOpValues, _kTCompareOpNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kTBloomFilterTypeValues[] = {
  TBloomFilterType::NONE,
  TBloomFilterType::ROW,
  TBloomFilterType::ROWCOL,
  TBloomFilterType::ROWPREFIX_FIXED_LENGTH
};
const char* _kTBloomFilterTypeNames[] = {
  "NONE",
  "ROW",
  "ROWCOL",
  "ROWPREFIX_FIXED_LENGTH"
};
const std::map<int, const char*> _TBloomFilterType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(4, _kTBloomFilterTypeValues, _kTBloomFilterTypeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kTCompressionAlgorithmValues[] = {
  TCompressionAlgorithm::LZO,
  TCompressionAlgorithm::GZ,
  TCompressionAlgorithm::NONE,
  TCompressionAlgorithm::SNAPPY,
  TCompressionAlgorithm::LZ4,
  TCompressionAlgorithm::BZIP2,
  TCompressionAlgorithm::ZSTD
};
const char* _kTCompressionAlgorithmNames[] = {
  "LZO",
  "GZ",
  "NONE",
  "SNAPPY",
  "LZ4",
  "BZIP2",
  "ZSTD"
};
const std::map<int, const char*> _TCompressionAlgorithm_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(7, _kTCompressionAlgorithmValues, _kTCompressionAlgorithmNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kTDataBlockEncodingValues[] = {
  TDataBlockEncoding::NONE,
  TDataBlockEncoding::PREFIX,
  TDataBlockEncoding::DIFF,
  TDataBlockEncoding::FAST_DIFF,
  TDataBlockEncoding::ROW_INDEX_V1
};
const char* _kTDataBlockEncodingNames[] = {
  "NONE",
  "PREFIX",
  "DIFF",
  "FAST_DIFF",
  "ROW_INDEX_V1"
};
const std::map<int, const char*> _TDataBlockEncoding_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(5, _kTDataBlockEncodingValues, _kTDataBlockEncodingNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kTKeepDeletedCellsValues[] = {
  TKeepDeletedCells::FALSE,
  TKeepDeletedCells::TRUE,
  TKeepDeletedCells::TTL
};
const char* _kTKeepDeletedCellsNames[] = {
  "FALSE",
  "TRUE",
  "TTL"
};
const std::map<int, const char*> _TKeepDeletedCells_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(3, _kTKeepDeletedCellsValues, _kTKeepDeletedCellsNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kTLogTypeValues[] = {
  TLogType::SLOW_LOG,
  TLogType::LARGE_LOG
};
const char* _kTLogTypeNames[] = {
  "SLOW_LOG",
  "LARGE_LOG"
};
const std::map<int, const char*> _TLogType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(2, _kTLogTypeValues, _kTLogTypeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kTFilterByOperatorValues[] = {
  TFilterByOperator::AND,
  TFilterByOperator::OR
};
const char* _kTFilterByOperatorNames[] = {
  "AND",
  "OR"
};
const std::map<int, const char*> _TFilterByOperator_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(2, _kTFilterByOperatorValues, _kTFilterByOperatorNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kTThriftServerTypeValues[] = {
  TThriftServerType::ONE,
  TThriftServerType::TWO
};
const char* _kTThriftServerTypeNames[] = {
  "ONE",
  "TWO"
};
const std::map<int, const char*> _TThriftServerType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(2, _kTThriftServerTypeValues, _kTThriftServerTypeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));


TTimeRange::~TTimeRange() throw() {
}


void TTimeRange::__set_minStamp(const int64_t val) {
  this->minStamp = val;
}

void TTimeRange::__set_maxStamp(const int64_t val) {
  this->maxStamp = val;
}

const char* TTimeRange::ascii_fingerprint = "F33135321253DAEB67B0E79E416CA831";
const uint8_t TTimeRange::binary_fingerprint[16] = {0xF3,0x31,0x35,0x32,0x12,0x53,0xDA,0xEB,0x67,0xB0,0xE7,0x9E,0x41,0x6C,0xA8,0x31};

uint32_t TTimeRange::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_minStamp = false;
  bool isset_maxStamp = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->minStamp);
          isset_minStamp = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->maxStamp);
          isset_maxStamp = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_minStamp)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_maxStamp)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TTimeRange::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  oprot->incrementRecursionDepth();
  xfer += oprot->writeStructBegin("TTimeRange");

  xfer += oprot->writeFieldBegin("minStamp", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->minStamp);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("maxStamp", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->maxStamp);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  oprot->decrementRecursionDepth();
  return xfer;
}

void swap(TTimeRange &a, TTimeRange &b) {
  using ::std::swap;
  swap(a.minStamp, b.minStamp);
  swap(a.maxStamp, b.maxStamp);
}

TTimeRange::TTimeRange(const TTimeRange& other0) {
  minStamp = other0.minStamp;
  maxStamp = other0.maxStamp;
}
TTimeRange& TTimeRange::operator=(const TTimeRange& other1) {
  minStamp = other1.minStamp;
  maxStamp = other1.maxStamp;
  return *this;
}
std::ostream& operator<<(std::ostream& out, const TTimeRange& obj) {
  using apache::thrift::to_string;
  out << "TTimeRange(";
  out << "minStamp=" << to_string(obj.minStamp);
  out << ", " << "maxStamp=" << to_string(obj.maxStamp);
  out << ")";
  return out;
}


TColumn::~TColumn() throw() {
}


void TColumn::__set_family(const std::string& val) {
  this->family = val;
}

void TColumn::__set_qualifier(const std::string& val) {
  this->qualifier = val;
__isset.qualifier = true;
}

void TColumn::__set_timestamp(const int64_t val) {
  this->timestamp = val;
__isset.timestamp = true;
}

const char* TColumn::ascii_fingerprint = "354B89A42CE318BBBCE588A386D5D6CD";
const uint8_t TColumn::binary_fingerprint[16] = {0x35,0x4B,0x89,0xA4,0x2C,0xE3,0x18,0xBB,0xBC,0xE5,0x88,0xA3,0x86,0xD5,0xD6,0xCD};

uint32_t TColumn::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_family = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->family);
          isset_family = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->qualifier);
          this->__isset.qualifier = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->timestamp);
          this->__isset.timestamp = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_family)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TColumn::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  oprot->incrementRecursionDepth();
  xfer += oprot->writeStructBegin("TColumn");

  xfer += oprot->writeFieldBegin("family", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeBinary(this->family);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.qualifier) {
    xfer += oprot->writeFieldBegin("qualifier", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeBinary(this->qualifier);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.timestamp) {
    xfer += oprot->writeFieldBegin("timestamp", ::apache::thrift::protocol::T_I64, 3);
    xfer += oprot->writeI64(this->timestamp);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  oprot->decrementRecursionDepth();
  return xfer;
}

void swap(TColumn &a, TColumn &b) {
  using ::std::swap;
  swap(a.family, b.family);
  swap(a.qualifier, b.qualifier);
  swap(a.timestamp, b.timestamp);
  swap(a.__isset, b.__isset);
}

TColumn::TColumn(const TColumn& other2) {
  family = other2.family;
  qualifier = other2.qualifier;
  timestamp = other2.timestamp;
  __isset = other2.__isset;
}
TColumn& TColumn::operator=(const TColumn& other3) {
  family = other3.family;
  qualifier = other3.qualifier;
  timestamp = other3.timestamp;
  __isset = other3.__isset;
  return *this;
}
std::ostream& operator<<(std::ostream& out, const TColumn& obj) {
  using apache::thrift::to_string;
  out << "TColumn(";
  out << "family=" << to_string(obj.family);
  out << ", " << "qualifier="; (obj.__isset.qualifier ? (out << to_string(obj.qualifier)) : (out << "<null>"));
  out << ", " << "timestamp="; (obj.__isset.timestamp ? (out << to_string(obj.timestamp)) : (out << "<null>"));
  out << ")";
  return out;
}


TColumnValue::~TColumnValue() throw() {
}


void TColumnValue::__set_family(const std::string& val) {
  this->family = val;
}

void TColumnValue::__set_qualifier(const std::string& val) {
  this->qualifier = val;
}

void TColumnValue::__set_value(const std::string& val) {
  this->value = val;
}

void TColumnValue::__set_timestamp(const int64_t val) {
  this->timestamp = val;
__isset.timestamp = true;
}

void TColumnValue::__set_tags(const std::string& val) {
  this->tags = val;
__isset.tags = true;
}

void TColumnValue::__set_type(const int8_t val) {
  this->type = val;
__isset.type = true;
}

const char* TColumnValue::ascii_fingerprint = "65C351854DFBF62D6B2BCFB2FA804844";
const uint8_t TColumnValue::binary_fingerprint[16] = {0x65,0xC3,0x51,0x85,0x4D,0xFB,0xF6,0x2D,0x6B,0x2B,0xCF,0xB2,0xFA,0x80,0x48,0x44};

uint32_t TColumnValue::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_family = false;
  bool isset_qualifier = false;
  bool isset_value = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->family);
          isset_family = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->qualifier);
          isset_qualifier = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->value);
          isset_value = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->timestamp);
          this->__isset.timestamp = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->tags);
          this->__isset.tags = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_BYTE) {
          xfer += iprot->readByte(this->type);
          this->__isset.type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_family)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_qualifier)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_value)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TColumnValue::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  oprot->incrementRecursionDepth();
  xfer += oprot->writeStructBegin("TColumnValue");

  xfer += oprot->writeFieldBegin("family", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeBinary(this->family);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("qualifier", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeBinary(this->qualifier);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("value", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeBinary(this->value);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.timestamp) {
    xfer += oprot->writeFieldBegin("timestamp", ::apache::thrift::protocol::T_I64, 4);
    xfer += oprot->writeI64(this->timestamp);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.tags) {
    xfer += oprot->writeFieldBegin("tags", ::apache::thrift::protocol::T_STRING, 5);
    xfer += oprot->writeBinary(this->tags);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.type) {
    xfer += oprot->writeFieldBegin("type", ::apache::thrift::protocol::T_BYTE, 6);
    xfer += oprot->writeByte(this->type);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  oprot->decrementRecursionDepth();
  return xfer;
}

void swap(TColumnValue &a, TColumnValue &b) {
  using ::std::swap;
  swap(a.family, b.family);
  swap(a.qualifier, b.qualifier);
  swap(a.value, b.value);
  swap(a.timestamp, b.timestamp);
  swap(a.tags, b.tags);
  swap(a.type, b.type);
  swap(a.__isset, b.__isset);
}

TColumnValue::TColumnValue(const TColumnValue& other4) {
  family = other4.family;
  qualifier = other4.qualifier;
  value = other4.value;
  timestamp = other4.timestamp;
  tags = other4.tags;
  type = other4.type;
  __isset = other4.__isset;
}
TColumnValue& TColumnValue::operator=(const TColumnValue& other5) {
  family = other5.family;
  qualifier = other5.qualifier;
  value = other5.value;
  timestamp = other5.timestamp;
  tags = other5.tags;
  type = other5.type;
  __isset = other5.__isset;
  return *this;
}
std::ostream& operator<<(std::ostream& out, const TColumnValue& obj) {
  using apache::thrift::to_string;
  out << "TColumnValue(";
  out << "family=" << to_string(obj.family);
  out << ", " << "qualifier=" << to_string(obj.qualifier);
  out << ", " << "value=" << to_string(obj.value);
  out << ", " << "timestamp="; (obj.__isset.timestamp ? (out << to_string(obj.timestamp)) : (out << "<null>"));
  out << ", " << "tags="; (obj.__isset.tags ? (out << to_string(obj.tags)) : (out << "<null>"));
  out << ", " << "type="; (obj.__isset.type ? (out << to_string(obj.type)) : (out << "<null>"));
  out << ")";
  return out;
}


TColumnIncrement::~TColumnIncrement() throw() {
}


void TColumnIncrement::__set_family(const std::string& val) {
  this->family = val;
}

void TColumnIncrement::__set_qualifier(const std::string& val) {
  this->qualifier = val;
}

void TColumnIncrement::__set_amount(const int64_t val) {
  this->amount = val;
__isset.amount = true;
}

const char* TColumnIncrement::ascii_fingerprint = "C55F1CDA80E5E1836AFA7E590331D0A5";
const uint8_t TColumnIncrement::binary_fingerprint[16] = {0xC5,0x5F,0x1C,0xDA,0x80,0xE5,0xE1,0x83,0x6A,0xFA,0x7E,0x59,0x03,0x31,0xD0,0xA5};

uint32_t TColumnIncrement::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_family = false;
  bool isset_qualifier = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->family);
          isset_family = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->qualifier);
          isset_qualifier = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->amount);
          this->__isset.amount = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_family)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_qualifier)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TColumnIncrement::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  oprot->incrementRecursionDepth();
  xfer += oprot->writeStructBegin("TColumnIncrement");

  xfer += oprot->writeFieldBegin("family", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeBinary(this->family);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("qualifier", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeBinary(this->qualifier);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.amount) {
    xfer += oprot->writeFieldBegin("amount", ::apache::thrift::protocol::T_I64, 3);
    xfer += oprot->writeI64(this->amount);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  oprot->decrementRecursionDepth();
  return xfer;
}

void swap(TColumnIncrement &a, TColumnIncrement &b) {
  using ::std::swap;
  swap(a.family, b.family);
  swap(a.qualifier, b.qualifier);
  swap(a.amount, b.amount);
  swap(a.__isset, b.__isset);
}

TColumnIncrement::TColumnIncrement(const TColumnIncrement& other6) {
  family = other6.family;
  qualifier = other6.qualifier;
  amount = other6.amount;
  __isset = other6.__isset;
}
TColumnIncrement& TColumnIncrement::operator=(const TColumnIncrement& other7) {
  family = other7.family;
  qualifier = other7.qualifier;
  amount = other7.amount;
  __isset = other7.__isset;
  return *this;
}
std::ostream& operator<<(std::ostream& out, const TColumnIncrement& obj) {
  using apache::thrift::to_string;
  out << "TColumnIncrement(";
  out << "family=" << to_string(obj.family);
  out << ", " << "qualifier=" << to_string(obj.qualifier);
  out << ", " << "amount="; (obj.__isset.amount ? (out << to_string(obj.amount)) : (out << "<null>"));
  out << ")";
  return out;
}


TResult::~TResult() throw() {
}


void TResult::__set_row(const std::string& val) {
  this->row = val;
__isset.row = true;
}

void TResult::__set_columnValues(const std::vector<TColumnValue> & val) {
  this->columnValues = val;
}

void TResult::__set_stale(const bool val) {
  this->stale = val;
__isset.stale = true;
}

void TResult::__set_partial(const bool val) {
  this->partial = val;
__isset.partial = true;
}

const char* TResult::ascii_fingerprint = "ED801A7807FE100E997823D4501A553B";
const uint8_t TResult::binary_fingerprint[16] = {0xED,0x80,0x1A,0x78,0x07,0xFE,0x10,0x0E,0x99,0x78,0x23,0xD4,0x50,0x1A,0x55,0x3B};

uint32_t TResult::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_columnValues = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->row);
          this->__isset.row = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->columnValues.clear();
            uint32_t _size8;
            ::apache::thrift::protocol::TType _etype11;
            xfer += iprot->readListBegin(_etype11, _size8);
            this->columnValues.resize(_size8);
            uint32_t _i12;
            for (_i12 = 0; _i12 < _size8; ++_i12)
            {
              xfer += this->columnValues[_i12].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_columnValues = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->stale);
          this->__isset.stale = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->partial);
          this->__isset.partial = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_columnValues)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TResult::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  oprot->incrementRecursionDepth();
  xfer += oprot->writeStructBegin("TResult");

  if (this->__isset.row) {
    xfer += oprot->writeFieldBegin("row", ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot->writeBinary(this->row);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldBegin("columnValues", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->columnValues.size()));
    std::vector<TColumnValue> ::const_iterator _iter13;
    for (_iter13 = this->columnValues.begin(); _iter13 != this->columnValues.end(); ++_iter13)
    {
      xfer += (*_iter13).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  if (this->__isset.stale) {
    xfer += oprot->writeFieldBegin("stale", ::apache::thrift::protocol::T_BOOL, 3);
    xfer += oprot->writeBool(this->stale);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.partial) {
    xfer += oprot->writeFieldBegin("partial", ::apache::thrift::protocol::T_BOOL, 4);
    xfer += oprot->writeBool(this->partial);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  oprot->decrementRecursionDepth();
  return xfer;
}

void swap(TResult &a, TResult &b) {
  using ::std::swap;
  swap(a.row, b.row);
  swap(a.columnValues, b.columnValues);
  swap(a.stale, b.stale);
  swap(a.partial, b.partial);
  swap(a.__isset, b.__isset);
}

TResult::TResult(const TResult& other14) {
  row = other14.row;
  columnValues = other14.columnValues;
  stale = other14.stale;
  partial = other14.partial;
  __isset = other14.__isset;
}
TResult& TResult::operator=(const TResult& other15) {
  row = other15.row;
  columnValues = other15.columnValues;
  stale = other15.stale;
  partial = other15.partial;
  __isset = other15.__isset;
  return *this;
}
std::ostream& operator<<(std::ostream& out, const TResult& obj) {
  using apache::thrift::to_string;
  out << "TResult(";
  out << "row="; (obj.__isset.row ? (out << to_string(obj.row)) : (out << "<null>"));
  out << ", " << "columnValues=" << to_string(obj.columnValues);
  out << ", " << "stale="; (obj.__isset.stale ? (out << to_string(obj.stale)) : (out << "<null>"));
  out << ", " << "partial="; (obj.__isset.partial ? (out << to_string(obj.partial)) : (out << "<null>"));
  out << ")";
  return out;
}


TAuthorization::~TAuthorization() throw() {
}


void TAuthorization::__set_labels(const std::vector<std::string> & val) {
  this->labels = val;
__isset.labels = true;
}

const char* TAuthorization::ascii_fingerprint = "6A3474ADDA840BE2091105F0DFB630C7";
const uint8_t TAuthorization::binary_fingerprint[16] = {0x6A,0x34,0x74,0xAD,0xDA,0x84,0x0B,0xE2,0x09,0x11,0x05,0xF0,0xDF,0xB6,0x30,0xC7};

uint32_t TAuthorization::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->labels.clear();
            uint32_t _size16;
            ::apache::thrift::protocol::TType _etype19;
            xfer += iprot->readListBegin(_etype19, _size16);
            this->labels.resize(_size16);
            uint32_t _i20;
            for (_i20 = 0; _i20 < _size16; ++_i20)
            {
              xfer += iprot->readString(this->labels[_i20]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.labels = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TAuthorization::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  oprot->incrementRecursionDepth();
  xfer += oprot->writeStructBegin("TAuthorization");

  if (this->__isset.labels) {
    xfer += oprot->writeFieldBegin("labels", ::apache::thrift::protocol::T_LIST, 1);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->labels.size()));
      std::vector<std::string> ::const_iterator _iter21;
      for (_iter21 = this->labels.begin(); _iter21 != this->labels.end(); ++_iter21)
      {
        xfer += oprot->writeString((*_iter21));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  oprot->decrementRecursionDepth();
  return xfer;
}

void swap(TAuthorization &a, TAuthorization &b) {
  using ::std::swap;
  swap(a.labels, b.labels);
  swap(a.__isset, b.__isset);
}

TAuthorization::TAuthorization(const TAuthorization& other22) {
  labels = other22.labels;
  __isset = other22.__isset;
}
TAuthorization& TAuthorization::operator=(const TAuthorization& other23) {
  labels = other23.labels;
  __isset = other23.__isset;
  return *this;
}
std::ostream& operator<<(std::ostream& out, const TAuthorization& obj) {
  using apache::thrift::to_string;
  out << "TAuthorization(";
  out << "labels="; (obj.__isset.labels ? (out << to_string(obj.labels)) : (out << "<null>"));
  out << ")";
  return out;
}


TCellVisibility::~TCellVisibility() throw() {
}


void TCellVisibility::__set_expression(const std::string& val) {
  this->expression = val;
__isset.expression = true;
}

const char* TCellVisibility::ascii_fingerprint = "66E694018C17E5B65A59AE8F55CCA3CD";
const uint8_t TCellVisibility::binary_fingerprint[16] = {0x66,0xE6,0x94,0x01,0x8C,0x17,0xE5,0xB6,0x5A,0x59,0xAE,0x8F,0x55,0xCC,0xA3,0xCD};

uint32_t TCellVisibility::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->expression);
          this->__isset.expression = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TCellVisibility::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  oprot->incrementRecursionDepth();
  xfer += oprot->writeStructBegin("TCellVisibility");

  if (this->__isset.expression) {
    xfer += oprot->writeFieldBegin("expression", ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot->writeString(this->expression);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  oprot->decrementRecursionDepth();
  return xfer;
}

void swap(TCellVisibility &a, TCellVisibility &b) {
  using ::std::swap;
  swap(a.expression, b.expression);
  swap(a.__isset, b.__isset);
}

TCellVisibility::TCellVisibility(const TCellVisibility& other24) {
  expression = other24.expression;
  __isset = other24.__isset;
}
TCellVisibility& TCellVisibility::operator=(const TCellVisibility& other25) {
  expression = other25.expression;
  __isset = other25.__isset;
  return *this;
}
std::ostream& operator<<(std::ostream& out, const TCellVisibility& obj) {
  using apache::thrift::to_string;
  out << "TCellVisibility(";
  out << "expression="; (obj.__isset.expression ? (out << to_string(obj.expression)) : (out << "<null>"));
  out << ")";
  return out;
}


TGet::~TGet() throw() {
}


void TGet::__set_row(const std::string& val) {
  this->row = val;
}

void TGet::__set_columns(const std::vector<TColumn> & val) {
  this->columns = val;
__isset.columns = true;
}

void TGet::__set_timestamp(const int64_t val) {
  this->timestamp = val;
__isset.timestamp = true;
}

void TGet::__set_timeRange(const TTimeRange& val) {
  this->timeRange = val;
__isset.timeRange = true;
}

void TGet::__set_maxVersions(const int32_t val) {
  this->maxVersions = val;
__isset.maxVersions = true;
}

void TGet::__set_filterString(const std::string& val) {
  this->filterString = val;
__isset.filterString = true;
}

void TGet::__set_attributes(const std::map<std::string, std::string> & val) {
  this->attributes = val;
__isset.attributes = true;
}

void TGet::__set_authorizations(const TAuthorization& val) {
  this->authorizations = val;
__isset.authorizations = true;
}

void TGet::__set_consistency(const TConsistency::type val) {
  this->consistency = val;
__isset.consistency = true;
}

void TGet::__set_targetReplicaId(const int32_t val) {
  this->targetReplicaId = val;
__isset.targetReplicaId = true;
}

void TGet::__set_cacheBlocks(const bool val) {
  this->cacheBlocks = val;
__isset.cacheBlocks = true;
}

void TGet::__set_storeLimit(const int32_t val) {
  this->storeLimit = val;
__isset.storeLimit = true;
}

void TGet::__set_storeOffset(const int32_t val) {
  this->storeOffset = val;
__isset.storeOffset = true;
}

void TGet::__set_existence_only(const bool val) {
  this->existence_only = val;
__isset.existence_only = true;
}

void TGet::__set_filterBytes(const std::string& val) {
  this->filterBytes = val;
__isset.filterBytes = true;
}

const char* TGet::ascii_fingerprint = "EC3FAE31621A7A6F276FABD32EF03CDA";
const uint8_t TGet::binary_fingerprint[16] = {0xEC,0x3F,0xAE,0x31,0x62,0x1A,0x7A,0x6F,0x27,0x6F,0xAB,0xD3,0x2E,0xF0,0x3C,0xDA};

uint32_t TGet::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_row = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->row);
          isset_row = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->columns.clear();
            uint32_t _size26;
            ::apache::thrift::protocol::TType _etype29;
            xfer += iprot->readListBegin(_etype29, _size26);
            this->columns.resize(_size26);
            uint32_t _i30;
            for (_i30 = 0; _i30 < _size26; ++_i30)
            {
              xfer += this->columns[_i30].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.columns = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->timestamp);
          this->__isset.timestamp = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->timeRange.read(iprot);
          this->__isset.timeRange = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->maxVersions);
          this->__isset.maxVersions = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->filterString);
          this->__isset.filterString = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->attributes.clear();
            uint32_t _size31;
            ::apache::thrift::protocol::TType _ktype32;
            ::apache::thrift::protocol::TType _vtype33;
            xfer += iprot->readMapBegin(_ktype32, _vtype33, _size31);
            uint32_t _i35;
            for (_i35 = 0; _i35 < _size31; ++_i35)
            {
              std::string _key36;
              xfer += iprot->readBinary(_key36);
              std::string& _val37 = this->attributes[_key36];
              xfer += iprot->readBinary(_val37);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.attributes = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->authorizations.read(iprot);
          this->__isset.authorizations = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast38;
          xfer += iprot->readI32(ecast38);
          this->consistency = (TConsistency::type)ecast38;
          this->__isset.consistency = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->targetReplicaId);
          this->__isset.targetReplicaId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->cacheBlocks);
          this->__isset.cacheBlocks = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 12:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->storeLimit);
          this->__isset.storeLimit = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 13:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->storeOffset);
          this->__isset.storeOffset = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 14:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->existence_only);
          this->__isset.existence_only = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 15:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->filterBytes);
          this->__isset.filterBytes = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_row)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TGet::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  oprot->incrementRecursionDepth();
  xfer += oprot->writeStructBegin("TGet");

  xfer += oprot->writeFieldBegin("row", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeBinary(this->row);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.columns) {
    xfer += oprot->writeFieldBegin("columns", ::apache::thrift::protocol::T_LIST, 2);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->columns.size()));
      std::vector<TColumn> ::const_iterator _iter39;
      for (_iter39 = this->columns.begin(); _iter39 != this->columns.end(); ++_iter39)
      {
        xfer += (*_iter39).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.timestamp) {
    xfer += oprot->writeFieldBegin("timestamp", ::apache::thrift::protocol::T_I64, 3);
    xfer += oprot->writeI64(this->timestamp);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.timeRange) {
    xfer += oprot->writeFieldBegin("timeRange", ::apache::thrift::protocol::T_STRUCT, 4);
    xfer += this->timeRange.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.maxVersions) {
    xfer += oprot->writeFieldBegin("maxVersions", ::apache::thrift::protocol::T_I32, 5);
    xfer += oprot->writeI32(this->maxVersions);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.filterString) {
    xfer += oprot->writeFieldBegin("filterString", ::apache::thrift::protocol::T_STRING, 6);
    xfer += oprot->writeBinary(this->filterString);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.attributes) {
    xfer += oprot->writeFieldBegin("attributes", ::apache::thrift::protocol::T_MAP, 7);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->attributes.size()));
      std::map<std::string, std::string> ::const_iterator _iter40;
      for (_iter40 = this->attributes.begin(); _iter40 != this->attributes.end(); ++_iter40)
      {
        xfer += oprot->writeBinary(_iter40->first);
        xfer += oprot->writeBinary(_iter40->second);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.authorizations) {
    xfer += oprot->writeFieldBegin("authorizations", ::apache::thrift::protocol::T_STRUCT, 8);
    xfer += this->authorizations.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.consistency) {
    xfer += oprot->writeFieldBegin("consistency", ::apache::thrift::protocol::T_I32, 9);
    xfer += oprot->writeI32((int32_t)this->consistency);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.targetReplicaId) {
    xfer += oprot->writeFieldBegin("targetReplicaId", ::apache::thrift::protocol::T_I32, 10);
    xfer += oprot->writeI32(this->targetReplicaId);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.cacheBlocks) {
    xfer += oprot->writeFieldBegin("cacheBlocks", ::apache::thrift::protocol::T_BOOL, 11);
    xfer += oprot->writeBool(this->cacheBlocks);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.storeLimit) {
    xfer += oprot->writeFieldBegin("storeLimit", ::apache::thrift::protocol::T_I32, 12);
    xfer += oprot->writeI32(this->storeLimit);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.storeOffset) {
    xfer += oprot->writeFieldBegin("storeOffset", ::apache::thrift::protocol::T_I32, 13);
    xfer += oprot->writeI32(this->storeOffset);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.existence_only) {
    xfer += oprot->writeFieldBegin("existence_only", ::apache::thrift::protocol::T_BOOL, 14);
    xfer += oprot->writeBool(this->existence_only);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.filterBytes) {
    xfer += oprot->writeFieldBegin("filterBytes", ::apache::thrift::protocol::T_STRING, 15);
    xfer += oprot->writeBinary(this->filterBytes);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  oprot->decrementRecursionDepth();
  return xfer;
}

void swap(TGet &a, TGet &b) {
  using ::std::swap;
  swap(a.row, b.row);
  swap(a.columns, b.columns);
  swap(a.timestamp, b.timestamp);
  swap(a.timeRange, b.timeRange);
  swap(a.maxVersions, b.maxVersions);
  swap(a.filterString, b.filterString);
  swap(a.attributes, b.attributes);
  swap(a.authorizations, b.authorizations);
  swap(a.consistency, b.consistency);
  swap(a.targetReplicaId, b.targetReplicaId);
  swap(a.cacheBlocks, b.cacheBlocks);
  swap(a.storeLimit, b.storeLimit);
  swap(a.storeOffset, b.storeOffset);
  swap(a.existence_only, b.existence_only);
  swap(a.filterBytes, b.filterBytes);
  swap(a.__isset, b.__isset);
}

TGet::TGet(const TGet& other41) {
  row = other41.row;
  columns = other41.columns;
  timestamp = other41.timestamp;
  timeRange = other41.timeRange;
  maxVersions = other41.maxVersions;
  filterString = other41.filterString;
  attributes = other41.attributes;
  authorizations = other41.authorizations;
  consistency = other41.consistency;
  targetReplicaId = other41.targetReplicaId;
  cacheBlocks = other41.cacheBlocks;
  storeLimit = other41.storeLimit;
  storeOffset = other41.storeOffset;
  existence_only = other41.existence_only;
  filterBytes = other41.filterBytes;
  __isset = other41.__isset;
}
TGet& TGet::operator=(const TGet& other42) {
  row = other42.row;
  columns = other42.columns;
  timestamp = other42.timestamp;
  timeRange = other42.timeRange;
  maxVersions = other42.maxVersions;
  filterString = other42.filterString;
  attributes = other42.attributes;
  authorizations = other42.authorizations;
  consistency = other42.consistency;
  targetReplicaId = other42.targetReplicaId;
  cacheBlocks = other42.cacheBlocks;
  storeLimit = other42.storeLimit;
  storeOffset = other42.storeOffset;
  existence_only = other42.existence_only;
  filterBytes = other42.filterBytes;
  __isset = other42.__isset;
  return *this;
}
std::ostream& operator<<(std::ostream& out, const TGet& obj) {
  using apache::thrift::to_string;
  out << "TGet(";
  out << "row=" << to_string(obj.row);
  out << ", " << "columns="; (obj.__isset.columns ? (out << to_string(obj.columns)) : (out << "<null>"));
  out << ", " << "timestamp="; (obj.__isset.timestamp ? (out << to_string(obj.timestamp)) : (out << "<null>"));
  out << ", " << "timeRange="; (obj.__isset.timeRange ? (out << to_string(obj.timeRange)) : (out << "<null>"));
  out << ", " << "maxVersions="; (obj.__isset.maxVersions ? (out << to_string(obj.maxVersions)) : (out << "<null>"));
  out << ", " << "filterString="; (obj.__isset.filterString ? (out << to_string(obj.filterString)) : (out << "<null>"));
  out << ", " << "attributes="; (obj.__isset.attributes ? (out << to_string(obj.attributes)) : (out << "<null>"));
  out << ", " << "authorizations="; (obj.__isset.authorizations ? (out << to_string(obj.authorizations)) : (out << "<null>"));
  out << ", " << "consistency="; (obj.__isset.consistency ? (out << to_string(obj.consistency)) : (out << "<null>"));
  out << ", " << "targetReplicaId="; (obj.__isset.targetReplicaId ? (out << to_string(obj.targetReplicaId)) : (out << "<null>"));
  out << ", " << "cacheBlocks="; (obj.__isset.cacheBlocks ? (out << to_string(obj.cacheBlocks)) : (out << "<null>"));
  out << ", " << "storeLimit="; (obj.__isset.storeLimit ? (out << to_string(obj.storeLimit)) : (out << "<null>"));
  out << ", " << "storeOffset="; (obj.__isset.storeOffset ? (out << to_string(obj.storeOffset)) : (out << "<null>"));
  out << ", " << "existence_only="; (obj.__isset.existence_only ? (out << to_string(obj.existence_only)) : (out << "<null>"));
  out << ", " << "filterBytes="; (obj.__isset.filterBytes ? (out << to_string(obj.filterBytes)) : (out << "<null>"));
  out << ")";
  return out;
}


TPut::~TPut() throw() {
}


void TPut::__set_row(const std::string& val) {
  this->row = val;
}

void TPut::__set_columnValues(const std::vector<TColumnValue> & val) {
  this->columnValues = val;
}

void TPut::__set_timestamp(const int64_t val) {
  this->timestamp = val;
__isset.timestamp = true;
}

void TPut::__set_attributes(const std::map<std::string, std::string> & val) {
  this->attributes = val;
__isset.attributes = true;
}

void TPut::__set_durability(const TDurability::type val) {
  this->durability = val;
__isset.durability = true;
}

void TPut::__set_cellVisibility(const TCellVisibility& val) {
  this->cellVisibility = val;
__isset.cellVisibility = true;
}

const char* TPut::ascii_fingerprint = "0F2E9F071BB47BD4F4B360F6C0312550";
const uint8_t TPut::binary_fingerprint[16] = {0x0F,0x2E,0x9F,0x07,0x1B,0xB4,0x7B,0xD4,0xF4,0xB3,0x60,0xF6,0xC0,0x31,0x25,0x50};

uint32_t TPut::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_row = false;
  bool isset_columnValues = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->row);
          isset_row = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->columnValues.clear();
            uint32_t _size43;
            ::apache::thrift::protocol::TType _etype46;
            xfer += iprot->readListBegin(_etype46, _size43);
            this->columnValues.resize(_size43);
            uint32_t _i47;
            for (_i47 = 0; _i47 < _size43; ++_i47)
            {
              xfer += this->columnValues[_i47].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_columnValues = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->timestamp);
          this->__isset.timestamp = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->attributes.clear();
            uint32_t _size48;
            ::apache::thrift::protocol::TType _ktype49;
            ::apache::thrift::protocol::TType _vtype50;
            xfer += iprot->readMapBegin(_ktype49, _vtype50, _size48);
            uint32_t _i52;
            for (_i52 = 0; _i52 < _size48; ++_i52)
            {
              std::string _key53;
              xfer += iprot->readBinary(_key53);
              std::string& _val54 = this->attributes[_key53];
              xfer += iprot->readBinary(_val54);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.attributes = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast55;
          xfer += iprot->readI32(ecast55);
          this->durability = (TDurability::type)ecast55;
          this->__isset.durability = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->cellVisibility.read(iprot);
          this->__isset.cellVisibility = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_row)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_columnValues)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TPut::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  oprot->incrementRecursionDepth();
  xfer += oprot->writeStructBegin("TPut");

  xfer += oprot->writeFieldBegin("row", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeBinary(this->row);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("columnValues", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->columnValues.size()));
    std::vector<TColumnValue> ::const_iterator _iter56;
    for (_iter56 = this->columnValues.begin(); _iter56 != this->columnValues.end(); ++_iter56)
    {
      xfer += (*_iter56).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  if (this->__isset.timestamp) {
    xfer += oprot->writeFieldBegin("timestamp", ::apache::thrift::protocol::T_I64, 3);
    xfer += oprot->writeI64(this->timestamp);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.attributes) {
    xfer += oprot->writeFieldBegin("attributes", ::apache::thrift::protocol::T_MAP, 5);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->attributes.size()));
      std::map<std::string, std::string> ::const_iterator _iter57;
      for (_iter57 = this->attributes.begin(); _iter57 != this->attributes.end(); ++_iter57)
      {
        xfer += oprot->writeBinary(_iter57->first);
        xfer += oprot->writeBinary(_iter57->second);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.durability) {
    xfer += oprot->writeFieldBegin("durability", ::apache::thrift::protocol::T_I32, 6);
    xfer += oprot->writeI32((int32_t)this->durability);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.cellVisibility) {
    xfer += oprot->writeFieldBegin("cellVisibility", ::apache::thrift::protocol::T_STRUCT, 7);
    xfer += this->cellVisibility.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  oprot->decrementRecursionDepth();
  return xfer;
}

void swap(TPut &a, TPut &b) {
  using ::std::swap;
  swap(a.row, b.row);
  swap(a.columnValues, b.columnValues);
  swap(a.timestamp, b.timestamp);
  swap(a.attributes, b.attributes);
  swap(a.durability, b.durability);
  swap(a.cellVisibility, b.cellVisibility);
  swap(a.__isset, b.__isset);
}

TPut::TPut(const TPut& other58) {
  row = other58.row;
  columnValues = other58.columnValues;
  timestamp = other58.timestamp;
  attributes = other58.attributes;
  durability = other58.durability;
  cellVisibility = other58.cellVisibility;
  __isset = other58.__isset;
}
TPut& TPut::operator=(const TPut& other59) {
  row = other59.row;
  columnValues = other59.columnValues;
  timestamp = other59.timestamp;
  attributes = other59.attributes;
  durability = other59.durability;
  cellVisibility = other59.cellVisibility;
  __isset = other59.__isset;
  return *this;
}
std::ostream& operator<<(std::ostream& out, const TPut& obj) {
  using apache::thrift::to_string;
  out << "TPut(";
  out << "row=" << to_string(obj.row);
  out << ", " << "columnValues=" << to_string(obj.columnValues);
  out << ", " << "timestamp="; (obj.__isset.timestamp ? (out << to_string(obj.timestamp)) : (out << "<null>"));
  out << ", " << "attributes="; (obj.__isset.attributes ? (out << to_string(obj.attributes)) : (out << "<null>"));
  out << ", " << "durability="; (obj.__isset.durability ? (out << to_string(obj.durability)) : (out << "<null>"));
  out << ", " << "cellVisibility="; (obj.__isset.cellVisibility ? (out << to_string(obj.cellVisibility)) : (out << "<null>"));
  out << ")";
  return out;
}


TDelete::~TDelete() throw() {
}


void TDelete::__set_row(const std::string& val) {
  this->row = val;
}

void TDelete::__set_columns(const std::vector<TColumn> & val) {
  this->columns = val;
__isset.columns = true;
}

void TDelete::__set_timestamp(const int64_t val) {
  this->timestamp = val;
__isset.timestamp = true;
}

void TDelete::__set_deleteType(const TDeleteType::type val) {
  this->deleteType = val;
__isset.deleteType = true;
}

void TDelete::__set_attributes(const std::map<std::string, std::string> & val) {
  this->attributes = val;
__isset.attributes = true;
}

void TDelete::__set_durability(const TDurability::type val) {
  this->durability = val;
__isset.durability = true;
}

const char* TDelete::ascii_fingerprint = "84640DFE212CEB30848C27DC77C196F0";
const uint8_t TDelete::binary_fingerprint[16] = {0x84,0x64,0x0D,0xFE,0x21,0x2C,0xEB,0x30,0x84,0x8C,0x27,0xDC,0x77,0xC1,0x96,0xF0};

uint32_t TDelete::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_row = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->row);
          isset_row = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->columns.clear();
            uint32_t _size60;
            ::apache::thrift::protocol::TType _etype63;
            xfer += iprot->readListBegin(_etype63, _size60);
            this->columns.resize(_size60);
            uint32_t _i64;
            for (_i64 = 0; _i64 < _size60; ++_i64)
            {
              xfer += this->columns[_i64].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.columns = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->timestamp);
          this->__isset.timestamp = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast65;
          xfer += iprot->readI32(ecast65);
          this->deleteType = (TDeleteType::type)ecast65;
          this->__isset.deleteType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->attributes.clear();
            uint32_t _size66;
            ::apache::thrift::protocol::TType _ktype67;
            ::apache::thrift::protocol::TType _vtype68;
            xfer += iprot->readMapBegin(_ktype67, _vtype68, _size66);
            uint32_t _i70;
            for (_i70 = 0; _i70 < _size66; ++_i70)
            {
              std::string _key71;
              xfer += iprot->readBinary(_key71);
              std::string& _val72 = this->attributes[_key71];
              xfer += iprot->readBinary(_val72);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.attributes = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast73;
          xfer += iprot->readI32(ecast73);
          this->durability = (TDurability::type)ecast73;
          this->__isset.durability = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_row)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TDelete::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  oprot->incrementRecursionDepth();
  xfer += oprot->writeStructBegin("TDelete");

  xfer += oprot->writeFieldBegin("row", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeBinary(this->row);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.columns) {
    xfer += oprot->writeFieldBegin("columns", ::apache::thrift::protocol::T_LIST, 2);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->columns.size()));
      std::vector<TColumn> ::const_iterator _iter74;
      for (_iter74 = this->columns.begin(); _iter74 != this->columns.end(); ++_iter74)
      {
        xfer += (*_iter74).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.timestamp) {
    xfer += oprot->writeFieldBegin("timestamp", ::apache::thrift::protocol::T_I64, 3);
    xfer += oprot->writeI64(this->timestamp);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.deleteType) {
    xfer += oprot->writeFieldBegin("deleteType", ::apache::thrift::protocol::T_I32, 4);
    xfer += oprot->writeI32((int32_t)this->deleteType);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.attributes) {
    xfer += oprot->writeFieldBegin("attributes", ::apache::thrift::protocol::T_MAP, 6);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->attributes.size()));
      std::map<std::string, std::string> ::const_iterator _iter75;
      for (_iter75 = this->attributes.begin(); _iter75 != this->attributes.end(); ++_iter75)
      {
        xfer += oprot->writeBinary(_iter75->first);
        xfer += oprot->writeBinary(_iter75->second);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.durability) {
    xfer += oprot->writeFieldBegin("durability", ::apache::thrift::protocol::T_I32, 7);
    xfer += oprot->writeI32((int32_t)this->durability);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  oprot->decrementRecursionDepth();
  return xfer;
}

void swap(TDelete &a, TDelete &b) {
  using ::std::swap;
  swap(a.row, b.row);
  swap(a.columns, b.columns);
  swap(a.timestamp, b.timestamp);
  swap(a.deleteType, b.deleteType);
  swap(a.attributes, b.attributes);
  swap(a.durability, b.durability);
  swap(a.__isset, b.__isset);
}

TDelete::TDelete(const TDelete& other76) {
  row = other76.row;
  columns = other76.columns;
  timestamp = other76.timestamp;
  deleteType = other76.deleteType;
  attributes = other76.attributes;
  durability = other76.durability;
  __isset = other76.__isset;
}
TDelete& TDelete::operator=(const TDelete& other77) {
  row = other77.row;
  columns = other77.columns;
  timestamp = other77.timestamp;
  deleteType = other77.deleteType;
  attributes = other77.attributes;
  durability = other77.durability;
  __isset = other77.__isset;
  return *this;
}
std::ostream& operator<<(std::ostream& out, const TDelete& obj) {
  using apache::thrift::to_string;
  out << "TDelete(";
  out << "row=" << to_string(obj.row);
  out << ", " << "columns="; (obj.__isset.columns ? (out << to_string(obj.columns)) : (out << "<null>"));
  out << ", " << "timestamp="; (obj.__isset.timestamp ? (out << to_string(obj.timestamp)) : (out << "<null>"));
  out << ", " << "deleteType="; (obj.__isset.deleteType ? (out << to_string(obj.deleteType)) : (out << "<null>"));
  out << ", " << "attributes="; (obj.__isset.attributes ? (out << to_string(obj.attributes)) : (out << "<null>"));
  out << ", " << "durability="; (obj.__isset.durability ? (out << to_string(obj.durability)) : (out << "<null>"));
  out << ")";
  return out;
}


TIncrement::~TIncrement() throw() {
}


void TIncrement::__set_row(const std::string& val) {
  this->row = val;
}

void TIncrement::__set_columns(const std::vector<TColumnIncrement> & val) {
  this->columns = val;
}

void TIncrement::__set_attributes(const std::map<std::string, std::string> & val) {
  this->attributes = val;
__isset.attributes = true;
}

void TIncrement::__set_durability(const TDurability::type val) {
  this->durability = val;
__isset.durability = true;
}

void TIncrement::__set_cellVisibility(const TCellVisibility& val) {
  this->cellVisibility = val;
__isset.cellVisibility = true;
}

void TIncrement::__set_returnResults(const bool val) {
  this->returnResults = val;
__isset.returnResults = true;
}

const char* TIncrement::ascii_fingerprint = "31146EBCF1F761ADE4552E104DAD4CFB";
const uint8_t TIncrement::binary_fingerprint[16] = {0x31,0x14,0x6E,0xBC,0xF1,0xF7,0x61,0xAD,0xE4,0x55,0x2E,0x10,0x4D,0xAD,0x4C,0xFB};

uint32_t TIncrement::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_row = false;
  bool isset_columns = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->row);
          isset_row = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->columns.clear();
            uint32_t _size78;
            ::apache::thrift::protocol::TType _etype81;
            xfer += iprot->readListBegin(_etype81, _size78);
            this->columns.resize(_size78);
            uint32_t _i82;
            for (_i82 = 0; _i82 < _size78; ++_i82)
            {
              xfer += this->columns[_i82].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_columns = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->attributes.clear();
            uint32_t _size83;
            ::apache::thrift::protocol::TType _ktype84;
            ::apache::thrift::protocol::TType _vtype85;
            xfer += iprot->readMapBegin(_ktype84, _vtype85, _size83);
            uint32_t _i87;
            for (_i87 = 0; _i87 < _size83; ++_i87)
            {
              std::string _key88;
              xfer += iprot->readBinary(_key88);
              std::string& _val89 = this->attributes[_key88];
              xfer += iprot->readBinary(_val89);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.attributes = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast90;
          xfer += iprot->readI32(ecast90);
          this->durability = (TDurability::type)ecast90;
          this->__isset.durability = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->cellVisibility.read(iprot);
          this->__isset.cellVisibility = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->returnResults);
          this->__isset.returnResults = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_row)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_columns)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TIncrement::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  oprot->incrementRecursionDepth();
  xfer += oprot->writeStructBegin("TIncrement");

  xfer += oprot->writeFieldBegin("row", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeBinary(this->row);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("columns", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->columns.size()));
    std::vector<TColumnIncrement> ::const_iterator _iter91;
    for (_iter91 = this->columns.begin(); _iter91 != this->columns.end(); ++_iter91)
    {
      xfer += (*_iter91).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  if (this->__isset.attributes) {
    xfer += oprot->writeFieldBegin("attributes", ::apache::thrift::protocol::T_MAP, 4);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->attributes.size()));
      std::map<std::string, std::string> ::const_iterator _iter92;
      for (_iter92 = this->attributes.begin(); _iter92 != this->attributes.end(); ++_iter92)
      {
        xfer += oprot->writeBinary(_iter92->first);
        xfer += oprot->writeBinary(_iter92->second);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.durability) {
    xfer += oprot->writeFieldBegin("durability", ::apache::thrift::protocol::T_I32, 5);
    xfer += oprot->writeI32((int32_t)this->durability);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.cellVisibility) {
    xfer += oprot->writeFieldBegin("cellVisibility", ::apache::thrift::protocol::T_STRUCT, 6);
    xfer += this->cellVisibility.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.returnResults) {
    xfer += oprot->writeFieldBegin("returnResults", ::apache::thrift::protocol::T_BOOL, 7);
    xfer += oprot->writeBool(this->returnResults);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  oprot->decrementRecursionDepth();
  return xfer;
}

void swap(TIncrement &a, TIncrement &b) {
  using ::std::swap;
  swap(a.row, b.row);
  swap(a.columns, b.columns);
  swap(a.attributes, b.attributes);
  swap(a.durability, b.durability);
  swap(a.cellVisibility, b.cellVisibility);
  swap(a.returnResults, b.returnResults);
  swap(a.__isset, b.__isset);
}

TIncrement::TIncrement(const TIncrement& other93) {
  row = other93.row;
  columns = other93.columns;
  attributes = other93.attributes;
  durability = other93.durability;
  cellVisibility = other93.cellVisibility;
  returnResults = other93.returnResults;
  __isset = other93.__isset;
}
TIncrement& TIncrement::operator=(const TIncrement& other94) {
  row = other94.row;
  columns = other94.columns;
  attributes = other94.attributes;
  durability = other94.durability;
  cellVisibility = other94.cellVisibility;
  returnResults = other94.returnResults;
  __isset = other94.__isset;
  return *this;
}
std::ostream& operator<<(std::ostream& out, const TIncrement& obj) {
  using apache::thrift::to_string;
  out << "TIncrement(";
  out << "row=" << to_string(obj.row);
  out << ", " << "columns=" << to_string(obj.columns);
  out << ", " << "attributes="; (obj.__isset.attributes ? (out << to_string(obj.attributes)) : (out << "<null>"));
  out << ", " << "durability="; (obj.__isset.durability ? (out << to_string(obj.durability)) : (out << "<null>"));
  out << ", " << "cellVisibility="; (obj.__isset.cellVisibility ? (out << to_string(obj.cellVisibility)) : (out << "<null>"));
  out << ", " << "returnResults="; (obj.__isset.returnResults ? (out << to_string(obj.returnResults)) : (out << "<null>"));
  out << ")";
  return out;
}


TAppend::~TAppend() throw() {
}


void TAppend::__set_row(const std::string& val) {
  this->row = val;
}

void TAppend::__set_columns(const std::vector<TColumnValue> & val) {
  this->columns = val;
}

void TAppend::__set_attributes(const std::map<std::string, std::string> & val) {
  this->attributes = val;
__isset.attributes = true;
}

void TAppend::__set_durability(const TDurability::type val) {
  this->durability = val;
__isset.durability = true;
}

void TAppend::__set_cellVisibility(const TCellVisibility& val) {
  this->cellVisibility = val;
__isset.cellVisibility = true;
}

void TAppend::__set_returnResults(const bool val) {
  this->returnResults = val;
__isset.returnResults = true;
}

const char* TAppend::ascii_fingerprint = "75772F463E7AB576E9AD8BC91682AC12";
const uint8_t TAppend::binary_fingerprint[16] = {0x75,0x77,0x2F,0x46,0x3E,0x7A,0xB5,0x76,0xE9,0xAD,0x8B,0xC9,0x16,0x82,0xAC,0x12};

uint32_t TAppend::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_row = false;
  bool isset_columns = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->row);
          isset_row = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->columns.clear();
            uint32_t _size95;
            ::apache::thrift::protocol::TType _etype98;
            xfer += iprot->readListBegin(_etype98, _size95);
            this->columns.resize(_size95);
            uint32_t _i99;
            for (_i99 = 0; _i99 < _size95; ++_i99)
            {
              xfer += this->columns[_i99].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_columns = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->attributes.clear();
            uint32_t _size100;
            ::apache::thrift::protocol::TType _ktype101;
            ::apache::thrift::protocol::TType _vtype102;
            xfer += iprot->readMapBegin(_ktype101, _vtype102, _size100);
            uint32_t _i104;
            for (_i104 = 0; _i104 < _size100; ++_i104)
            {
              std::string _key105;
              xfer += iprot->readBinary(_key105);
              std::string& _val106 = this->attributes[_key105];
              xfer += iprot->readBinary(_val106);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.attributes = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast107;
          xfer += iprot->readI32(ecast107);
          this->durability = (TDurability::type)ecast107;
          this->__isset.durability = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->cellVisibility.read(iprot);
          this->__isset.cellVisibility = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->returnResults);
          this->__isset.returnResults = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_row)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_columns)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TAppend::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  oprot->incrementRecursionDepth();
  xfer += oprot->writeStructBegin("TAppend");

  xfer += oprot->writeFieldBegin("row", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeBinary(this->row);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("columns", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->columns.size()));
    std::vector<TColumnValue> ::const_iterator _iter108;
    for (_iter108 = this->columns.begin(); _iter108 != this->columns.end(); ++_iter108)
    {
      xfer += (*_iter108).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  if (this->__isset.attributes) {
    xfer += oprot->writeFieldBegin("attributes", ::apache::thrift::protocol::T_MAP, 3);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->attributes.size()));
      std::map<std::string, std::string> ::const_iterator _iter109;
      for (_iter109 = this->attributes.begin(); _iter109 != this->attributes.end(); ++_iter109)
      {
        xfer += oprot->writeBinary(_iter109->first);
        xfer += oprot->writeBinary(_iter109->second);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.durability) {
    xfer += oprot->writeFieldBegin("durability", ::apache::thrift::protocol::T_I32, 4);
    xfer += oprot->writeI32((int32_t)this->durability);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.cellVisibility) {
    xfer += oprot->writeFieldBegin("cellVisibility", ::apache::thrift::protocol::T_STRUCT, 5);
    xfer += this->cellVisibility.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.returnResults) {
    xfer += oprot->writeFieldBegin("returnResults", ::apache::thrift::protocol::T_BOOL, 6);
    xfer += oprot->writeBool(this->returnResults);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  oprot->decrementRecursionDepth();
  return xfer;
}

void swap(TAppend &a, TAppend &b) {
  using ::std::swap;
  swap(a.row, b.row);
  swap(a.columns, b.columns);
  swap(a.attributes, b.attributes);
  swap(a.durability, b.durability);
  swap(a.cellVisibility, b.cellVisibility);
  swap(a.returnResults, b.returnResults);
  swap(a.__isset, b.__isset);
}

TAppend::TAppend(const TAppend& other110) {
  row = other110.row;
  columns = other110.columns;
  attributes = other110.attributes;
  durability = other110.durability;
  cellVisibility = other110.cellVisibility;
  returnResults = other110.returnResults;
  __isset = other110.__isset;
}
TAppend& TAppend::operator=(const TAppend& other111) {
  row = other111.row;
  columns = other111.columns;
  attributes = other111.attributes;
  durability = other111.durability;
  cellVisibility = other111.cellVisibility;
  returnResults = other111.returnResults;
  __isset = other111.__isset;
  return *this;
}
std::ostream& operator<<(std::ostream& out, const TAppend& obj) {
  using apache::thrift::to_string;
  out << "TAppend(";
  out << "row=" << to_string(obj.row);
  out << ", " << "columns=" << to_string(obj.columns);
  out << ", " << "attributes="; (obj.__isset.attributes ? (out << to_string(obj.attributes)) : (out << "<null>"));
  out << ", " << "durability="; (obj.__isset.durability ? (out << to_string(obj.durability)) : (out << "<null>"));
  out << ", " << "cellVisibility="; (obj.__isset.cellVisibility ? (out << to_string(obj.cellVisibility)) : (out << "<null>"));
  out << ", " << "returnResults="; (obj.__isset.returnResults ? (out << to_string(obj.returnResults)) : (out << "<null>"));
  out << ")";
  return out;
}


TScan::~TScan() throw() {
}


void TScan::__set_startRow(const std::string& val) {
  this->startRow = val;
__isset.startRow = true;
}

void TScan::__set_stopRow(const std::string& val) {
  this->stopRow = val;
__isset.stopRow = true;
}

void TScan::__set_columns(const std::vector<TColumn> & val) {
  this->columns = val;
__isset.columns = true;
}

void TScan::__set_caching(const int32_t val) {
  this->caching = val;
__isset.caching = true;
}

void TScan::__set_maxVersions(const int32_t val) {
  this->maxVersions = val;
__isset.maxVersions = true;
}

void TScan::__set_timeRange(const TTimeRange& val) {
  this->timeRange = val;
__isset.timeRange = true;
}

void TScan::__set_filterString(const std::string& val) {
  this->filterString = val;
__isset.filterString = true;
}

void TScan::__set_batchSize(const int32_t val) {
  this->batchSize = val;
__isset.batchSize = true;
}

void TScan::__set_attributes(const std::map<std::string, std::string> & val) {
  this->attributes = val;
__isset.attributes = true;
}

void TScan::__set_authorizations(const TAuthorization& val) {
  this->authorizations = val;
__isset.authorizations = true;
}

void TScan::__set_reversed(const bool val) {
  this->reversed = val;
__isset.reversed = true;
}

void TScan::__set_cacheBlocks(const bool val) {
  this->cacheBlocks = val;
__isset.cacheBlocks = true;
}

void TScan::__set_colFamTimeRangeMap(const std::map<std::string, TTimeRange> & val) {
  this->colFamTimeRangeMap = val;
__isset.colFamTimeRangeMap = true;
}

void TScan::__set_readType(const TReadType::type val) {
  this->readType = val;
__isset.readType = true;
}

void TScan::__set_limit(const int32_t val) {
  this->limit = val;
__isset.limit = true;
}

void TScan::__set_consistency(const TConsistency::type val) {
  this->consistency = val;
__isset.consistency = true;
}

void TScan::__set_targetReplicaId(const int32_t val) {
  this->targetReplicaId = val;
__isset.targetReplicaId = true;
}

void TScan::__set_filterBytes(const std::string& val) {
  this->filterBytes = val;
__isset.filterBytes = true;
}

const char* TScan::ascii_fingerprint = "C0FB8D6E398D5441FD662A767A674E71";
const uint8_t TScan::binary_fingerprint[16] = {0xC0,0xFB,0x8D,0x6E,0x39,0x8D,0x54,0x41,0xFD,0x66,0x2A,0x76,0x7A,0x67,0x4E,0x71};

uint32_t TScan::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->startRow);
          this->__isset.startRow = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->stopRow);
          this->__isset.stopRow = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->columns.clear();
            uint32_t _size112;
            ::apache::thrift::protocol::TType _etype115;
            xfer += iprot->readListBegin(_etype115, _size112);
            this->columns.resize(_size112);
            uint32_t _i116;
            for (_i116 = 0; _i116 < _size112; ++_i116)
            {
              xfer += this->columns[_i116].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.columns = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->caching);
          this->__isset.caching = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->maxVersions);
          this->__isset.maxVersions = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->timeRange.read(iprot);
          this->__isset.timeRange = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->filterString);
          this->__isset.filterString = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->batchSize);
          this->__isset.batchSize = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->attributes.clear();
            uint32_t _size117;
            ::apache::thrift::protocol::TType _ktype118;
            ::apache::thrift::protocol::TType _vtype119;
            xfer += iprot->readMapBegin(_ktype118, _vtype119, _size117);
            uint32_t _i121;
            for (_i121 = 0; _i121 < _size117; ++_i121)
            {
              std::string _key122;
              xfer += iprot->readBinary(_key122);
              std::string& _val123 = this->attributes[_key122];
              xfer += iprot->readBinary(_val123);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.attributes = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->authorizations.read(iprot);
          this->__isset.authorizations = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->reversed);
          this->__isset.reversed = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 12:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->cacheBlocks);
          this->__isset.cacheBlocks = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 13:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->colFamTimeRangeMap.clear();
            uint32_t _size124;
            ::apache::thrift::protocol::TType _ktype125;
            ::apache::thrift::protocol::TType _vtype126;
            xfer += iprot->readMapBegin(_ktype125, _vtype126, _size124);
            uint32_t _i128;
            for (_i128 = 0; _i128 < _size124; ++_i128)
            {
              std::string _key129;
              xfer += iprot->readBinary(_key129);
              TTimeRange& _val130 = this->colFamTimeRangeMap[_key129];
              xfer += _val130.read(iprot);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.colFamTimeRangeMap = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 14:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast131;
          xfer += iprot->readI32(ecast131);
          this->readType = (TReadType::type)ecast131;
          this->__isset.readType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 15:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->limit);
          this->__isset.limit = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 16:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast132;
          xfer += iprot->readI32(ecast132);
          this->consistency = (TConsistency::type)ecast132;
          this->__isset.consistency = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 17:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->targetReplicaId);
          this->__isset.targetReplicaId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 18:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->filterBytes);
          this->__isset.filterBytes = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TScan::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  oprot->incrementRecursionDepth();
  xfer += oprot->writeStructBegin("TScan");

  if (this->__isset.startRow) {
    xfer += oprot->writeFieldBegin("startRow", ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot->writeBinary(this->startRow);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.stopRow) {
    xfer += oprot->writeFieldBegin("stopRow", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeBinary(this->stopRow);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.columns) {
    xfer += oprot->writeFieldBegin("columns", ::apache::thrift::protocol::T_LIST, 3);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->columns.size()));
      std::vector<TColumn> ::const_iterator _iter133;
      for (_iter133 = this->columns.begin(); _iter133 != this->columns.end(); ++_iter133)
      {
        xfer += (*_iter133).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.caching) {
    xfer += oprot->writeFieldBegin("caching", ::apache::thrift::protocol::T_I32, 4);
    xfer += oprot->writeI32(this->caching);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.maxVersions) {
    xfer += oprot->writeFieldBegin("maxVersions", ::apache::thrift::protocol::T_I32, 5);
    xfer += oprot->writeI32(this->maxVersions);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.timeRange) {
    xfer += oprot->writeFieldBegin("timeRange", ::apache::thrift::protocol::T_STRUCT, 6);
    xfer += this->timeRange.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.filterString) {
    xfer += oprot->writeFieldBegin("filterString", ::apache::thrift::protocol::T_STRING, 7);
    xfer += oprot->writeBinary(this->filterString);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.batchSize) {
    xfer += oprot->writeFieldBegin("batchSize", ::apache::thrift::protocol::T_I32, 8);
    xfer += oprot->writeI32(this->batchSize);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.attributes) {
    xfer += oprot->writeFieldBegin("attributes", ::apache::thrift::protocol::T_MAP, 9);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->attributes.size()));
      std::map<std::string, std::string> ::const_iterator _iter134;
      for (_iter134 = this->attributes.begin(); _iter134 != this->attributes.end(); ++_iter134)
      {
        xfer += oprot->writeBinary(_iter134->first);
        xfer += oprot->writeBinary(_iter134->second);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.authorizations) {
    xfer += oprot->writeFieldBegin("authorizations", ::apache::thrift::protocol::T_STRUCT, 10);
    xfer += this->authorizations.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.reversed) {
    xfer += oprot->writeFieldBegin("reversed", ::apache::thrift::protocol::T_BOOL, 11);
    xfer += oprot->writeBool(this->reversed);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.cacheBlocks) {
    xfer += oprot->writeFieldBegin("cacheBlocks", ::apache::thrift::protocol::T_BOOL, 12);
    xfer += oprot->writeBool(this->cacheBlocks);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.colFamTimeRangeMap) {
    xfer += oprot->writeFieldBegin("colFamTimeRangeMap", ::apache::thrift::protocol::T_MAP, 13);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->colFamTimeRangeMap.size()));
      std::map<std::string, TTimeRange> ::const_iterator _iter135;
      for (_iter135 = this->colFamTimeRangeMap.begin(); _iter135 != this->colFamTimeRangeMap.end(); ++_iter135)
      {
        xfer += oprot->writeBinary(_iter135->first);
        xfer += _iter135->second.write(oprot);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.readType) {
    xfer += oprot->writeFieldBegin("readType", ::apache::thrift::protocol::T_I32, 14);
    xfer += oprot->writeI32((int32_t)this->readType);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.limit) {
    xfer += oprot->writeFieldBegin("limit", ::apache::thrift::protocol::T_I32, 15);
    xfer += oprot->writeI32(this->limit);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.consistency) {
    xfer += oprot->writeFieldBegin("consistency", ::apache::thrift::protocol::T_I32, 16);
    xfer += oprot->writeI32((int32_t)this->consistency);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.targetReplicaId) {
    xfer += oprot->writeFieldBegin("targetReplicaId", ::apache::thrift::protocol::T_I32, 17);
    xfer += oprot->writeI32(this->targetReplicaId);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.filterBytes) {
    xfer += oprot->writeFieldBegin("filterBytes", ::apache::thrift::protocol::T_STRING, 18);
    xfer += oprot->writeBinary(this->filterBytes);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  oprot->decrementRecursionDepth();
  return xfer;
}

void swap(TScan &a, TScan &b) {
  using ::std::swap;
  swap(a.startRow, b.startRow);
  swap(a.stopRow, b.stopRow);
  swap(a.columns, b.columns);
  swap(a.caching, b.caching);
  swap(a.maxVersions, b.maxVersions);
  swap(a.timeRange, b.timeRange);
  swap(a.filterString, b.filterString);
  swap(a.batchSize, b.batchSize);
  swap(a.attributes, b.attributes);
  swap(a.authorizations, b.authorizations);
  swap(a.reversed, b.reversed);
  swap(a.cacheBlocks, b.cacheBlocks);
  swap(a.colFamTimeRangeMap, b.colFamTimeRangeMap);
  swap(a.readType, b.readType);
  swap(a.limit, b.limit);
  swap(a.consistency, b.consistency);
  swap(a.targetReplicaId, b.targetReplicaId);
  swap(a.filterBytes, b.filterBytes);
  swap(a.__isset, b.__isset);
}

TScan::TScan(const TScan& other136) {
  startRow = other136.startRow;
  stopRow = other136.stopRow;
  columns = other136.columns;
  caching = other136.caching;
  maxVersions = other136.maxVersions;
  timeRange = other136.timeRange;
  filterString = other136.filterString;
  batchSize = other136.batchSize;
  attributes = other136.attributes;
  authorizations = other136.authorizations;
  reversed = other136.reversed;
  cacheBlocks = other136.cacheBlocks;
  colFamTimeRangeMap = other136.colFamTimeRangeMap;
  readType = other136.readType;
  limit = other136.limit;
  consistency = other136.consistency;
  targetReplicaId = other136.targetReplicaId;
  filterBytes = other136.filterBytes;
  __isset = other136.__isset;
}
TScan& TScan::operator=(const TScan& other137) {
  startRow = other137.startRow;
  stopRow = other137.stopRow;
  columns = other137.columns;
  caching = other137.caching;
  maxVersions = other137.maxVersions;
  timeRange = other137.timeRange;
  filterString = other137.filterString;
  batchSize = other137.batchSize;
  attributes = other137.attributes;
  authorizations = other137.authorizations;
  reversed = other137.reversed;
  cacheBlocks = other137.cacheBlocks;
  colFamTimeRangeMap = other137.colFamTimeRangeMap;
  readType = other137.readType;
  limit = other137.limit;
  consistency = other137.consistency;
  targetReplicaId = other137.targetReplicaId;
  filterBytes = other137.filterBytes;
  __isset = other137.__isset;
  return *this;
}
std::ostream& operator<<(std::ostream& out, const TScan& obj) {
  using apache::thrift::to_string;
  out << "TScan(";
  out << "startRow="; (obj.__isset.startRow ? (out << to_string(obj.startRow)) : (out << "<null>"));
  out << ", " << "stopRow="; (obj.__isset.stopRow ? (out << to_string(obj.stopRow)) : (out << "<null>"));
  out << ", " << "columns="; (obj.__isset.columns ? (out << to_string(obj.columns)) : (out << "<null>"));
  out << ", " << "caching="; (obj.__isset.caching ? (out << to_string(obj.caching)) : (out << "<null>"));
  out << ", " << "maxVersions="; (obj.__isset.maxVersions ? (out << to_string(obj.maxVersions)) : (out << "<null>"));
  out << ", " << "timeRange="; (obj.__isset.timeRange ? (out << to_string(obj.timeRange)) : (out << "<null>"));
  out << ", " << "filterString="; (obj.__isset.filterString ? (out << to_string(obj.filterString)) : (out << "<null>"));
  out << ", " << "batchSize="; (obj.__isset.batchSize ? (out << to_string(obj.batchSize)) : (out << "<null>"));
  out << ", " << "attributes="; (obj.__isset.attributes ? (out << to_string(obj.attributes)) : (out << "<null>"));
  out << ", " << "authorizations="; (obj.__isset.authorizations ? (out << to_string(obj.authorizations)) : (out << "<null>"));
  out << ", " << "reversed="; (obj.__isset.reversed ? (out << to_string(obj.reversed)) : (out << "<null>"));
  out << ", " << "cacheBlocks="; (obj.__isset.cacheBlocks ? (out << to_string(obj.cacheBlocks)) : (out << "<null>"));
  out << ", " << "colFamTimeRangeMap="; (obj.__isset.colFamTimeRangeMap ? (out << to_string(obj.colFamTimeRangeMap)) : (out << "<null>"));
  out << ", " << "readType="; (obj.__isset.readType ? (out << to_string(obj.readType)) : (out << "<null>"));
  out << ", " << "limit="; (obj.__isset.limit ? (out << to_string(obj.limit)) : (out << "<null>"));
  out << ", " << "consistency="; (obj.__isset.consistency ? (out << to_string(obj.consistency)) : (out << "<null>"));
  out << ", " << "targetReplicaId="; (obj.__isset.targetReplicaId ? (out << to_string(obj.targetReplicaId)) : (out << "<null>"));
  out << ", " << "filterBytes="; (obj.__isset.filterBytes ? (out << to_string(obj.filterBytes)) : (out << "<null>"));
  out << ")";
  return out;
}


TMutation::~TMutation() throw() {
}


void TMutation::__set_put(const TPut& val) {
  this->put = val;
}

void TMutation::__set_deleteSingle(const TDelete& val) {
  this->deleteSingle = val;
}

const char* TMutation::ascii_fingerprint = "46F3F4C6EC40992BBE15FA270D6ADEF5";
const uint8_t TMutation::binary_fingerprint[16] = {0x46,0xF3,0xF4,0xC6,0xEC,0x40,0x99,0x2B,0xBE,0x15,0xFA,0x27,0x0D,0x6A,0xDE,0xF5};

uint32_t TMutation::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->put.read(iprot);
          this->__isset.put = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->deleteSingle.read(iprot);
          this->__isset.deleteSingle = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TMutation::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  oprot->incrementRecursionDepth();
  xfer += oprot->writeStructBegin("TMutation");

  xfer += oprot->writeFieldBegin("put", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->put.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("deleteSingle", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->deleteSingle.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  oprot->decrementRecursionDepth();
  return xfer;
}

void swap(TMutation &a, TMutation &b) {
  using ::std::swap;
  swap(a.put, b.put);
  swap(a.deleteSingle, b.deleteSingle);
  swap(a.__isset, b.__isset);
}

TMutation::TMutation(const TMutation& other138) {
  put = other138.put;
  deleteSingle = other138.deleteSingle;
  __isset = other138.__isset;
}
TMutation& TMutation::operator=(const TMutation& other139) {
  put = other139.put;
  deleteSingle = other139.deleteSingle;
  __isset = other139.__isset;
  return *this;
}
std::ostream& operator<<(std::ostream& out, const TMutation& obj) {
  using apache::thrift::to_string;
  out << "TMutation(";
  out << "put=" << to_string(obj.put);
  out << ", " << "deleteSingle=" << to_string(obj.deleteSingle);
  out << ")";
  return out;
}


TRowMutations::~TRowMutations() throw() {
}


void TRowMutations::__set_row(const std::string& val) {
  this->row = val;
}

void TRowMutations::__set_mutations(const std::vector<TMutation> & val) {
  this->mutations = val;
}

const char* TRowMutations::ascii_fingerprint = "EB68318A0931133A26AA17B748D52040";
const uint8_t TRowMutations::binary_fingerprint[16] = {0xEB,0x68,0x31,0x8A,0x09,0x31,0x13,0x3A,0x26,0xAA,0x17,0xB7,0x48,0xD5,0x20,0x40};

uint32_t TRowMutations::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_row = false;
  bool isset_mutations = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->row);
          isset_row = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->mutations.clear();
            uint32_t _size140;
            ::apache::thrift::protocol::TType _etype143;
            xfer += iprot->readListBegin(_etype143, _size140);
            this->mutations.resize(_size140);
            uint32_t _i144;
            for (_i144 = 0; _i144 < _size140; ++_i144)
            {
              xfer += this->mutations[_i144].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_mutations = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_row)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_mutations)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TRowMutations::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  oprot->incrementRecursionDepth();
  xfer += oprot->writeStructBegin("TRowMutations");

  xfer += oprot->writeFieldBegin("row", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeBinary(this->row);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("mutations", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->mutations.size()));
    std::vector<TMutation> ::const_iterator _iter145;
    for (_iter145 = this->mutations.begin(); _iter145 != this->mutations.end(); ++_iter145)
    {
      xfer += (*_iter145).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  oprot->decrementRecursionDepth();
  return xfer;
}

void swap(TRowMutations &a, TRowMutations &b) {
  using ::std::swap;
  swap(a.row, b.row);
  swap(a.mutations, b.mutations);
}

TRowMutations::TRowMutations(const TRowMutations& other146) {
  row = other146.row;
  mutations = other146.mutations;
}
TRowMutations& TRowMutations::operator=(const TRowMutations& other147) {
  row = other147.row;
  mutations = other147.mutations;
  return *this;
}
std::ostream& operator<<(std::ostream& out, const TRowMutations& obj) {
  using apache::thrift::to_string;
  out << "TRowMutations(";
  out << "row=" << to_string(obj.row);
  out << ", " << "mutations=" << to_string(obj.mutations);
  out << ")";
  return out;
}


THRegionInfo::~THRegionInfo() throw() {
}


void THRegionInfo::__set_regionId(const int64_t val) {
  this->regionId = val;
}

void THRegionInfo::__set_tableName(const std::string& val) {
  this->tableName = val;
}

void THRegionInfo::__set_startKey(const std::string& val) {
  this->startKey = val;
__isset.startKey = true;
}

void THRegionInfo::__set_endKey(const std::string& val) {
  this->endKey = val;
__isset.endKey = true;
}

void THRegionInfo::__set_offline(const bool val) {
  this->offline = val;
__isset.offline = true;
}

void THRegionInfo::__set_split(const bool val) {
  this->split = val;
__isset.split = true;
}

void THRegionInfo::__set_replicaId(const int32_t val) {
  this->replicaId = val;
__isset.replicaId = true;
}

const char* THRegionInfo::ascii_fingerprint = "E29D5A124268D48991C782591956E9C4";
const uint8_t THRegionInfo::binary_fingerprint[16] = {0xE2,0x9D,0x5A,0x12,0x42,0x68,0xD4,0x89,0x91,0xC7,0x82,0x59,0x19,0x56,0xE9,0xC4};

uint32_t THRegionInfo::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_regionId = false;
  bool isset_tableName = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->regionId);
          isset_regionId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->tableName);
          isset_tableName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->startKey);
          this->__isset.startKey = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->endKey);
          this->__isset.endKey = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->offline);
          this->__isset.offline = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->split);
          this->__isset.split = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->replicaId);
          this->__isset.replicaId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_regionId)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_tableName)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t THRegionInfo::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  oprot->incrementRecursionDepth();
  xfer += oprot->writeStructBegin("THRegionInfo");

  xfer += oprot->writeFieldBegin("regionId", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->regionId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tableName", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeBinary(this->tableName);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.startKey) {
    xfer += oprot->writeFieldBegin("startKey", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeBinary(this->startKey);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.endKey) {
    xfer += oprot->writeFieldBegin("endKey", ::apache::thrift::protocol::T_STRING, 4);
    xfer += oprot->writeBinary(this->endKey);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.offline) {
    xfer += oprot->writeFieldBegin("offline", ::apache::thrift::protocol::T_BOOL, 5);
    xfer += oprot->writeBool(this->offline);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.split) {
    xfer += oprot->writeFieldBegin("split", ::apache::thrift::protocol::T_BOOL, 6);
    xfer += oprot->writeBool(this->split);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.replicaId) {
    xfer += oprot->writeFieldBegin("replicaId", ::apache::thrift::protocol::T_I32, 7);
    xfer += oprot->writeI32(this->replicaId);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  oprot->decrementRecursionDepth();
  return xfer;
}

void swap(THRegionInfo &a, THRegionInfo &b) {
  using ::std::swap;
  swap(a.regionId, b.regionId);
  swap(a.tableName, b.tableName);
  swap(a.startKey, b.startKey);
  swap(a.endKey, b.endKey);
  swap(a.offline, b.offline);
  swap(a.split, b.split);
  swap(a.replicaId, b.replicaId);
  swap(a.__isset, b.__isset);
}

THRegionInfo::THRegionInfo(const THRegionInfo& other148) {
  regionId = other148.regionId;
  tableName = other148.tableName;
  startKey = other148.startKey;
  endKey = other148.endKey;
  offline = other148.offline;
  split = other148.split;
  replicaId = other148.replicaId;
  __isset = other148.__isset;
}
THRegionInfo& THRegionInfo::operator=(const THRegionInfo& other149) {
  regionId = other149.regionId;
  tableName = other149.tableName;
  startKey = other149.startKey;
  endKey = other149.endKey;
  offline = other149.offline;
  split = other149.split;
  replicaId = other149.replicaId;
  __isset = other149.__isset;
  return *this;
}
std::ostream& operator<<(std::ostream& out, const THRegionInfo& obj) {
  using apache::thrift::to_string;
  out << "THRegionInfo(";
  out << "regionId=" << to_string(obj.regionId);
  out << ", " << "tableName=" << to_string(obj.tableName);
  out << ", " << "startKey="; (obj.__isset.startKey ? (out << to_string(obj.startKey)) : (out << "<null>"));
  out << ", " << "endKey="; (obj.__isset.endKey ? (out << to_string(obj.endKey)) : (out << "<null>"));
  out << ", " << "offline="; (obj.__isset.offline ? (out << to_string(obj.offline)) : (out << "<null>"));
  out << ", " << "split="; (obj.__isset.split ? (out << to_string(obj.split)) : (out << "<null>"));
  out << ", " << "replicaId="; (obj.__isset.replicaId ? (out << to_string(obj.replicaId)) : (out << "<null>"));
  out << ")";
  return out;
}


TServerName::~TServerName() throw() {
}


void TServerName::__set_hostName(const std::string& val) {
  this->hostName = val;
}

void TServerName::__set_port(const int32_t val) {
  this->port = val;
__isset.port = true;
}

void TServerName::__set_startCode(const int64_t val) {
  this->startCode = val;
__isset.startCode = true;
}

const char* TServerName::ascii_fingerprint = "382A5014141BA5C913BB4175A5B43756";
const uint8_t TServerName::binary_fingerprint[16] = {0x38,0x2A,0x50,0x14,0x14,0x1B,0xA5,0xC9,0x13,0xBB,0x41,0x75,0xA5,0xB4,0x37,0x56};

uint32_t TServerName::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_hostName = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->hostName);
          isset_hostName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->port);
          this->__isset.port = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->startCode);
          this->__isset.startCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_hostName)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TServerName::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  oprot->incrementRecursionDepth();
  xfer += oprot->writeStructBegin("TServerName");

  xfer += oprot->writeFieldBegin("hostName", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->hostName);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.port) {
    xfer += oprot->writeFieldBegin("port", ::apache::thrift::protocol::T_I32, 2);
    xfer += oprot->writeI32(this->port);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.startCode) {
    xfer += oprot->writeFieldBegin("startCode", ::apache::thrift::protocol::T_I64, 3);
    xfer += oprot->writeI64(this->startCode);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  oprot->decrementRecursionDepth();
  return xfer;
}

void swap(TServerName &a, TServerName &b) {
  using ::std::swap;
  swap(a.hostName, b.hostName);
  swap(a.port, b.port);
  swap(a.startCode, b.startCode);
  swap(a.__isset, b.__isset);
}

TServerName::TServerName(const TServerName& other150) {
  hostName = other150.hostName;
  port = other150.port;
  startCode = other150.startCode;
  __isset = other150.__isset;
}
TServerName& TServerName::operator=(const TServerName& other151) {
  hostName = other151.hostName;
  port = other151.port;
  startCode = other151.startCode;
  __isset = other151.__isset;
  return *this;
}
std::ostream& operator<<(std::ostream& out, const TServerName& obj) {
  using apache::thrift::to_string;
  out << "TServerName(";
  out << "hostName=" << to_string(obj.hostName);
  out << ", " << "port="; (obj.__isset.port ? (out << to_string(obj.port)) : (out << "<null>"));
  out << ", " << "startCode="; (obj.__isset.startCode ? (out << to_string(obj.startCode)) : (out << "<null>"));
  out << ")";
  return out;
}


THRegionLocation::~THRegionLocation() throw() {
}


void THRegionLocation::__set_serverName(const TServerName& val) {
  this->serverName = val;
}

void THRegionLocation::__set_regionInfo(const THRegionInfo& val) {
  this->regionInfo = val;
}

const char* THRegionLocation::ascii_fingerprint = "95ADA83616D80A12727CC523B6EFC295";
const uint8_t THRegionLocation::binary_fingerprint[16] = {0x95,0xAD,0xA8,0x36,0x16,0xD8,0x0A,0x12,0x72,0x7C,0xC5,0x23,0xB6,0xEF,0xC2,0x95};

uint32_t THRegionLocation::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_serverName = false;
  bool isset_regionInfo = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->serverName.read(iprot);
          isset_serverName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->regionInfo.read(iprot);
          isset_regionInfo = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_serverName)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_regionInfo)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t THRegionLocation::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  oprot->incrementRecursionDepth();
  xfer += oprot->writeStructBegin("THRegionLocation");

  xfer += oprot->writeFieldBegin("serverName", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->serverName.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("regionInfo", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->regionInfo.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  oprot->decrementRecursionDepth();
  return xfer;
}

void swap(THRegionLocation &a, THRegionLocation &b) {
  using ::std::swap;
  swap(a.serverName, b.serverName);
  swap(a.regionInfo, b.regionInfo);
}

THRegionLocation::THRegionLocation(const THRegionLocation& other152) {
  serverName = other152.serverName;
  regionInfo = other152.regionInfo;
}
THRegionLocation& THRegionLocation::operator=(const THRegionLocation& other153) {
  serverName = other153.serverName;
  regionInfo = other153.regionInfo;
  return *this;
}
std::ostream& operator<<(std::ostream& out, const THRegionLocation& obj) {
  using apache::thrift::to_string;
  out << "THRegionLocation(";
  out << "serverName=" << to_string(obj.serverName);
  out << ", " << "regionInfo=" << to_string(obj.regionInfo);
  out << ")";
  return out;
}


TTableName::~TTableName() throw() {
}


void TTableName::__set_ns(const std::string& val) {
  this->ns = val;
__isset.ns = true;
}

void TTableName::__set_qualifier(const std::string& val) {
  this->qualifier = val;
}

const char* TTableName::ascii_fingerprint = "383E55F0D02199A3E52B9227E13A83A2";
const uint8_t TTableName::binary_fingerprint[16] = {0x38,0x3E,0x55,0xF0,0xD0,0x21,0x99,0xA3,0xE5,0x2B,0x92,0x27,0xE1,0x3A,0x83,0xA2};

uint32_t TTableName::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_qualifier = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->ns);
          this->__isset.ns = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->qualifier);
          isset_qualifier = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_qualifier)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TTableName::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  oprot->incrementRecursionDepth();
  xfer += oprot->writeStructBegin("TTableName");

  if (this->__isset.ns) {
    xfer += oprot->writeFieldBegin("ns", ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot->writeBinary(this->ns);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldBegin("qualifier", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeBinary(this->qualifier);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  oprot->decrementRecursionDepth();
  return xfer;
}

void swap(TTableName &a, TTableName &b) {
  using ::std::swap;
  swap(a.ns, b.ns);
  swap(a.qualifier, b.qualifier);
  swap(a.__isset, b.__isset);
}

TTableName::TTableName(const TTableName& other154) {
  ns = other154.ns;
  qualifier = other154.qualifier;
  __isset = other154.__isset;
}
TTableName& TTableName::operator=(const TTableName& other155) {
  ns = other155.ns;
  qualifier = other155.qualifier;
  __isset = other155.__isset;
  return *this;
}
std::ostream& operator<<(std::ostream& out, const TTableName& obj) {
  using apache::thrift::to_string;
  out << "TTableName(";
  out << "ns="; (obj.__isset.ns ? (out << to_string(obj.ns)) : (out << "<null>"));
  out << ", " << "qualifier=" << to_string(obj.qualifier);
  out << ")";
  return out;
}


TColumnFamilyDescriptor::~TColumnFamilyDescriptor() throw() {
}


void TColumnFamilyDescriptor::__set_name(const std::string& val) {
  this->name = val;
}

void TColumnFamilyDescriptor::__set_attributes(const std::map<std::string, std::string> & val) {
  this->attributes = val;
__isset.attributes = true;
}

void TColumnFamilyDescriptor::__set_configuration(const std::map<std::string, std::string> & val) {
  this->configuration = val;
__isset.configuration = true;
}

void TColumnFamilyDescriptor::__set_blockSize(const int32_t val) {
  this->blockSize = val;
__isset.blockSize = true;
}

void TColumnFamilyDescriptor::__set_bloomnFilterType(const TBloomFilterType::type val) {
  this->bloomnFilterType = val;
__isset.bloomnFilterType = true;
}

void TColumnFamilyDescriptor::__set_compressionType(const TCompressionAlgorithm::type val) {
  this->compressionType = val;
__isset.compressionType = true;
}

void TColumnFamilyDescriptor::__set_dfsReplication(const int16_t val) {
  this->dfsReplication = val;
__isset.dfsReplication = true;
}

void TColumnFamilyDescriptor::__set_dataBlockEncoding(const TDataBlockEncoding::type val) {
  this->dataBlockEncoding = val;
__isset.dataBlockEncoding = true;
}

void TColumnFamilyDescriptor::__set_keepDeletedCells(const TKeepDeletedCells::type val) {
  this->keepDeletedCells = val;
__isset.keepDeletedCells = true;
}

void TColumnFamilyDescriptor::__set_maxVersions(const int32_t val) {
  this->maxVersions = val;
__isset.maxVersions = true;
}

void TColumnFamilyDescriptor::__set_minVersions(const int32_t val) {
  this->minVersions = val;
__isset.minVersions = true;
}

void TColumnFamilyDescriptor::__set_scope(const int32_t val) {
  this->scope = val;
__isset.scope = true;
}

void TColumnFamilyDescriptor::__set_timeToLive(const int32_t val) {
  this->timeToLive = val;
__isset.timeToLive = true;
}

void TColumnFamilyDescriptor::__set_blockCacheEnabled(const bool val) {
  this->blockCacheEnabled = val;
__isset.blockCacheEnabled = true;
}

void TColumnFamilyDescriptor::__set_cacheBloomsOnWrite(const bool val) {
  this->cacheBloomsOnWrite = val;
__isset.cacheBloomsOnWrite = true;
}

void TColumnFamilyDescriptor::__set_cacheDataOnWrite(const bool val) {
  this->cacheDataOnWrite = val;
__isset.cacheDataOnWrite = true;
}

void TColumnFamilyDescriptor::__set_cacheIndexesOnWrite(const bool val) {
  this->cacheIndexesOnWrite = val;
__isset.cacheIndexesOnWrite = true;
}

void TColumnFamilyDescriptor::__set_compressTags(const bool val) {
  this->compressTags = val;
__isset.compressTags = true;
}

void TColumnFamilyDescriptor::__set_evictBlocksOnClose(const bool val) {
  this->evictBlocksOnClose = val;
__isset.evictBlocksOnClose = true;
}

void TColumnFamilyDescriptor::__set_inMemory(const bool val) {
  this->inMemory = val;
__isset.inMemory = true;
}

const char* TColumnFamilyDescriptor::ascii_fingerprint = "0F1C03437C0BD5DB39B166A225239E5F";
const uint8_t TColumnFamilyDescriptor::binary_fingerprint[16] = {0x0F,0x1C,0x03,0x43,0x7C,0x0B,0xD5,0xDB,0x39,0xB1,0x66,0xA2,0x25,0x23,0x9E,0x5F};

uint32_t TColumnFamilyDescriptor::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_name = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->name);
          isset_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->attributes.clear();
            uint32_t _size156;
            ::apache::thrift::protocol::TType _ktype157;
            ::apache::thrift::protocol::TType _vtype158;
            xfer += iprot->readMapBegin(_ktype157, _vtype158, _size156);
            uint32_t _i160;
            for (_i160 = 0; _i160 < _size156; ++_i160)
            {
              std::string _key161;
              xfer += iprot->readBinary(_key161);
              std::string& _val162 = this->attributes[_key161];
              xfer += iprot->readBinary(_val162);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.attributes = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->configuration.clear();
            uint32_t _size163;
            ::apache::thrift::protocol::TType _ktype164;
            ::apache::thrift::protocol::TType _vtype165;
            xfer += iprot->readMapBegin(_ktype164, _vtype165, _size163);
            uint32_t _i167;
            for (_i167 = 0; _i167 < _size163; ++_i167)
            {
              std::string _key168;
              xfer += iprot->readString(_key168);
              std::string& _val169 = this->configuration[_key168];
              xfer += iprot->readString(_val169);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.configuration = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->blockSize);
          this->__isset.blockSize = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast170;
          xfer += iprot->readI32(ecast170);
          this->bloomnFilterType = (TBloomFilterType::type)ecast170;
          this->__isset.bloomnFilterType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast171;
          xfer += iprot->readI32(ecast171);
          this->compressionType = (TCompressionAlgorithm::type)ecast171;
          this->__isset.compressionType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->dfsReplication);
          this->__isset.dfsReplication = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast172;
          xfer += iprot->readI32(ecast172);
          this->dataBlockEncoding = (TDataBlockEncoding::type)ecast172;
          this->__isset.dataBlockEncoding = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast173;
          xfer += iprot->readI32(ecast173);
          this->keepDeletedCells = (TKeepDeletedCells::type)ecast173;
          this->__isset.keepDeletedCells = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->maxVersions);
          this->__isset.maxVersions = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->minVersions);
          this->__isset.minVersions = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 12:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->scope);
          this->__isset.scope = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 13:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->timeToLive);
          this->__isset.timeToLive = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 14:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->blockCacheEnabled);
          this->__isset.blockCacheEnabled = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 15:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->cacheBloomsOnWrite);
          this->__isset.cacheBloomsOnWrite = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 16:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->cacheDataOnWrite);
          this->__isset.cacheDataOnWrite = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 17:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->cacheIndexesOnWrite);
          this->__isset.cacheIndexesOnWrite = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 18:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->compressTags);
          this->__isset.compressTags = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 19:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->evictBlocksOnClose);
          this->__isset.evictBlocksOnClose = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 20:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->inMemory);
          this->__isset.inMemory = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_name)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TColumnFamilyDescriptor::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  oprot->incrementRecursionDepth();
  xfer += oprot->writeStructBegin("TColumnFamilyDescriptor");

  xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeBinary(this->name);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.attributes) {
    xfer += oprot->writeFieldBegin("attributes", ::apache::thrift::protocol::T_MAP, 2);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->attributes.size()));
      std::map<std::string, std::string> ::const_iterator _iter174;
      for (_iter174 = this->attributes.begin(); _iter174 != this->attributes.end(); ++_iter174)
      {
        xfer += oprot->writeBinary(_iter174->first);
        xfer += oprot->writeBinary(_iter174->second);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.configuration) {
    xfer += oprot->writeFieldBegin("configuration", ::apache::thrift::protocol::T_MAP, 3);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->configuration.size()));
      std::map<std::string, std::string> ::const_iterator _iter175;
      for (_iter175 = this->configuration.begin(); _iter175 != this->configuration.end(); ++_iter175)
      {
        xfer += oprot->writeString(_iter175->first);
        xfer += oprot->writeString(_iter175->second);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.blockSize) {
    xfer += oprot->writeFieldBegin("blockSize", ::apache::thrift::protocol::T_I32, 4);
    xfer += oprot->writeI32(this->blockSize);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.bloomnFilterType) {
    xfer += oprot->writeFieldBegin("bloomnFilterType", ::apache::thrift::protocol::T_I32, 5);
    xfer += oprot->writeI32((int32_t)this->bloomnFilterType);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.compressionType) {
    xfer += oprot->writeFieldBegin("compressionType", ::apache::thrift::protocol::T_I32, 6);
    xfer += oprot->writeI32((int32_t)this->compressionType);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.dfsReplication) {
    xfer += oprot->writeFieldBegin("dfsReplication", ::apache::thrift::protocol::T_I16, 7);
    xfer += oprot->writeI16(this->dfsReplication);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.dataBlockEncoding) {
    xfer += oprot->writeFieldBegin("dataBlockEncoding", ::apache::thrift::protocol::T_I32, 8);
    xfer += oprot->writeI32((int32_t)this->dataBlockEncoding);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.keepDeletedCells) {
    xfer += oprot->writeFieldBegin("keepDeletedCells", ::apache::thrift::protocol::T_I32, 9);
    xfer += oprot->writeI32((int32_t)this->keepDeletedCells);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.maxVersions) {
    xfer += oprot->writeFieldBegin("maxVersions", ::apache::thrift::protocol::T_I32, 10);
    xfer += oprot->writeI32(this->maxVersions);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.minVersions) {
    xfer += oprot->writeFieldBegin("minVersions", ::apache::thrift::protocol::T_I32, 11);
    xfer += oprot->writeI32(this->minVersions);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.scope) {
    xfer += oprot->writeFieldBegin("scope", ::apache::thrift::protocol::T_I32, 12);
    xfer += oprot->writeI32(this->scope);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.timeToLive) {
    xfer += oprot->writeFieldBegin("timeToLive", ::apache::thrift::protocol::T_I32, 13);
    xfer += oprot->writeI32(this->timeToLive);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.blockCacheEnabled) {
    xfer += oprot->writeFieldBegin("blockCacheEnabled", ::apache::thrift::protocol::T_BOOL, 14);
    xfer += oprot->writeBool(this->blockCacheEnabled);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.cacheBloomsOnWrite) {
    xfer += oprot->writeFieldBegin("cacheBloomsOnWrite", ::apache::thrift::protocol::T_BOOL, 15);
    xfer += oprot->writeBool(this->cacheBloomsOnWrite);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.cacheDataOnWrite) {
    xfer += oprot->writeFieldBegin("cacheDataOnWrite", ::apache::thrift::protocol::T_BOOL, 16);
    xfer += oprot->writeBool(this->cacheDataOnWrite);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.cacheIndexesOnWrite) {
    xfer += oprot->writeFieldBegin("cacheIndexesOnWrite", ::apache::thrift::protocol::T_BOOL, 17);
    xfer += oprot->writeBool(this->cacheIndexesOnWrite);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.compressTags) {
    xfer += oprot->writeFieldBegin("compressTags", ::apache::thrift::protocol::T_BOOL, 18);
    xfer += oprot->writeBool(this->compressTags);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.evictBlocksOnClose) {
    xfer += oprot->writeFieldBegin("evictBlocksOnClose", ::apache::thrift::protocol::T_BOOL, 19);
    xfer += oprot->writeBool(this->evictBlocksOnClose);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.inMemory) {
    xfer += oprot->writeFieldBegin("inMemory", ::apache::thrift::protocol::T_BOOL, 20);
    xfer += oprot->writeBool(this->inMemory);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  oprot->decrementRecursionDepth();
  return xfer;
}

void swap(TColumnFamilyDescriptor &a, TColumnFamilyDescriptor &b) {
  using ::std::swap;
  swap(a.name, b.name);
  swap(a.attributes, b.attributes);
  swap(a.configuration, b.configuration);
  swap(a.blockSize, b.blockSize);
  swap(a.bloomnFilterType, b.bloomnFilterType);
  swap(a.compressionType, b.compressionType);
  swap(a.dfsReplication, b.dfsReplication);
  swap(a.dataBlockEncoding, b.dataBlockEncoding);
  swap(a.keepDeletedCells, b.keepDeletedCells);
  swap(a.maxVersions, b.maxVersions);
  swap(a.minVersions, b.minVersions);
  swap(a.scope, b.scope);
  swap(a.timeToLive, b.timeToLive);
  swap(a.blockCacheEnabled, b.blockCacheEnabled);
  swap(a.cacheBloomsOnWrite, b.cacheBloomsOnWrite);
  swap(a.cacheDataOnWrite, b.cacheDataOnWrite);
  swap(a.cacheIndexesOnWrite, b.cacheIndexesOnWrite);
  swap(a.compressTags, b.compressTags);
  swap(a.evictBlocksOnClose, b.evictBlocksOnClose);
  swap(a.inMemory, b.inMemory);
  swap(a.__isset, b.__isset);
}

TColumnFamilyDescriptor::TColumnFamilyDescriptor(const TColumnFamilyDescriptor& other176) {
  name = other176.name;
  attributes = other176.attributes;
  configuration = other176.configuration;
  blockSize = other176.blockSize;
  bloomnFilterType = other176.bloomnFilterType;
  compressionType = other176.compressionType;
  dfsReplication = other176.dfsReplication;
  dataBlockEncoding = other176.dataBlockEncoding;
  keepDeletedCells = other176.keepDeletedCells;
  maxVersions = other176.maxVersions;
  minVersions = other176.minVersions;
  scope = other176.scope;
  timeToLive = other176.timeToLive;
  blockCacheEnabled = other176.blockCacheEnabled;
  cacheBloomsOnWrite = other176.cacheBloomsOnWrite;
  cacheDataOnWrite = other176.cacheDataOnWrite;
  cacheIndexesOnWrite = other176.cacheIndexesOnWrite;
  compressTags = other176.compressTags;
  evictBlocksOnClose = other176.evictBlocksOnClose;
  inMemory = other176.inMemory;
  __isset = other176.__isset;
}
TColumnFamilyDescriptor& TColumnFamilyDescriptor::operator=(const TColumnFamilyDescriptor& other177) {
  name = other177.name;
  attributes = other177.attributes;
  configuration = other177.configuration;
  blockSize = other177.blockSize;
  bloomnFilterType = other177.bloomnFilterType;
  compressionType = other177.compressionType;
  dfsReplication = other177.dfsReplication;
  dataBlockEncoding = other177.dataBlockEncoding;
  keepDeletedCells = other177.keepDeletedCells;
  maxVersions = other177.maxVersions;
  minVersions = other177.minVersions;
  scope = other177.scope;
  timeToLive = other177.timeToLive;
  blockCacheEnabled = other177.blockCacheEnabled;
  cacheBloomsOnWrite = other177.cacheBloomsOnWrite;
  cacheDataOnWrite = other177.cacheDataOnWrite;
  cacheIndexesOnWrite = other177.cacheIndexesOnWrite;
  compressTags = other177.compressTags;
  evictBlocksOnClose = other177.evictBlocksOnClose;
  inMemory = other177.inMemory;
  __isset = other177.__isset;
  return *this;
}
std::ostream& operator<<(std::ostream& out, const TColumnFamilyDescriptor& obj) {
  using apache::thrift::to_string;
  out << "TColumnFamilyDescriptor(";
  out << "name=" << to_string(obj.name);
  out << ", " << "attributes="; (obj.__isset.attributes ? (out << to_string(obj.attributes)) : (out << "<null>"));
  out << ", " << "configuration="; (obj.__isset.configuration ? (out << to_string(obj.configuration)) : (out << "<null>"));
  out << ", " << "blockSize="; (obj.__isset.blockSize ? (out << to_string(obj.blockSize)) : (out << "<null>"));
  out << ", " << "bloomnFilterType="; (obj.__isset.bloomnFilterType ? (out << to_string(obj.bloomnFilterType)) : (out << "<null>"));
  out << ", " << "compressionType="; (obj.__isset.compressionType ? (out << to_string(obj.compressionType)) : (out << "<null>"));
  out << ", " << "dfsReplication="; (obj.__isset.dfsReplication ? (out << to_string(obj.dfsReplication)) : (out << "<null>"));
  out << ", " << "dataBlockEncoding="; (obj.__isset.dataBlockEncoding ? (out << to_string(obj.dataBlockEncoding)) : (out << "<null>"));
  out << ", " << "keepDeletedCells="; (obj.__isset.keepDeletedCells ? (out << to_string(obj.keepDeletedCells)) : (out << "<null>"));
  out << ", " << "maxVersions="; (obj.__isset.maxVersions ? (out << to_string(obj.maxVersions)) : (out << "<null>"));
  out << ", " << "minVersions="; (obj.__isset.minVersions ? (out << to_string(obj.minVersions)) : (out << "<null>"));
  out << ", " << "scope="; (obj.__isset.scope ? (out << to_string(obj.scope)) : (out << "<null>"));
  out << ", " << "timeToLive="; (obj.__isset.timeToLive ? (out << to_string(obj.timeToLive)) : (out << "<null>"));
  out << ", " << "blockCacheEnabled="; (obj.__isset.blockCacheEnabled ? (out << to_string(obj.blockCacheEnabled)) : (out << "<null>"));
  out << ", " << "cacheBloomsOnWrite="; (obj.__isset.cacheBloomsOnWrite ? (out << to_string(obj.cacheBloomsOnWrite)) : (out << "<null>"));
  out << ", " << "cacheDataOnWrite="; (obj.__isset.cacheDataOnWrite ? (out << to_string(obj.cacheDataOnWrite)) : (out << "<null>"));
  out << ", " << "cacheIndexesOnWrite="; (obj.__isset.cacheIndexesOnWrite ? (out << to_string(obj.cacheIndexesOnWrite)) : (out << "<null>"));
  out << ", " << "compressTags="; (obj.__isset.compressTags ? (out << to_string(obj.compressTags)) : (out << "<null>"));
  out << ", " << "evictBlocksOnClose="; (obj.__isset.evictBlocksOnClose ? (out << to_string(obj.evictBlocksOnClose)) : (out << "<null>"));
  out << ", " << "inMemory="; (obj.__isset.inMemory ? (out << to_string(obj.inMemory)) : (out << "<null>"));
  out << ")";
  return out;
}


TTableDescriptor::~TTableDescriptor() throw() {
}


void TTableDescriptor::__set_tableName(const TTableName& val) {
  this->tableName = val;
}

void TTableDescriptor::__set_columns(const std::vector<TColumnFamilyDescriptor> & val) {
  this->columns = val;
__isset.columns = true;
}

void TTableDescriptor::__set_attributes(const std::map<std::string, std::string> & val) {
  this->attributes = val;
__isset.attributes = true;
}

void TTableDescriptor::__set_durability(const TDurability::type val) {
  this->durability = val;
__isset.durability = true;
}

const char* TTableDescriptor::ascii_fingerprint = "5259225B567357D5D97128B4CCDF5169";
const uint8_t TTableDescriptor::binary_fingerprint[16] = {0x52,0x59,0x22,0x5B,0x56,0x73,0x57,0xD5,0xD9,0x71,0x28,0xB4,0xCC,0xDF,0x51,0x69};

uint32_t TTableDescriptor::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_tableName = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->tableName.read(iprot);
          isset_tableName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->columns.clear();
            uint32_t _size178;
            ::apache::thrift::protocol::TType _etype181;
            xfer += iprot->readListBegin(_etype181, _size178);
            this->columns.resize(_size178);
            uint32_t _i182;
            for (_i182 = 0; _i182 < _size178; ++_i182)
            {
              xfer += this->columns[_i182].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.columns = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->attributes.clear();
            uint32_t _size183;
            ::apache::thrift::protocol::TType _ktype184;
            ::apache::thrift::protocol::TType _vtype185;
            xfer += iprot->readMapBegin(_ktype184, _vtype185, _size183);
            uint32_t _i187;
            for (_i187 = 0; _i187 < _size183; ++_i187)
            {
              std::string _key188;
              xfer += iprot->readBinary(_key188);
              std::string& _val189 = this->attributes[_key188];
              xfer += iprot->readBinary(_val189);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.attributes = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast190;
          xfer += iprot->readI32(ecast190);
          this->durability = (TDurability::type)ecast190;
          this->__isset.durability = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_tableName)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TTableDescriptor::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  oprot->incrementRecursionDepth();
  xfer += oprot->writeStructBegin("TTableDescriptor");

  xfer += oprot->writeFieldBegin("tableName", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->tableName.write(oprot);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.columns) {
    xfer += oprot->writeFieldBegin("columns", ::apache::thrift::protocol::T_LIST, 2);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->columns.size()));
      std::vector<TColumnFamilyDescriptor> ::const_iterator _iter191;
      for (_iter191 = this->columns.begin(); _iter191 != this->columns.end(); ++_iter191)
      {
        xfer += (*_iter191).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.attributes) {
    xfer += oprot->writeFieldBegin("attributes", ::apache::thrift::protocol::T_MAP, 3);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->attributes.size()));
      std::map<std::string, std::string> ::const_iterator _iter192;
      for (_iter192 = this->attributes.begin(); _iter192 != this->attributes.end(); ++_iter192)
      {
        xfer += oprot->writeBinary(_iter192->first);
        xfer += oprot->writeBinary(_iter192->second);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.durability) {
    xfer += oprot->writeFieldBegin("durability", ::apache::thrift::protocol::T_I32, 4);
    xfer += oprot->writeI32((int32_t)this->durability);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  oprot->decrementRecursionDepth();
  return xfer;
}

void swap(TTableDescriptor &a, TTableDescriptor &b) {
  using ::std::swap;
  swap(a.tableName, b.tableName);
  swap(a.columns, b.columns);
  swap(a.attributes, b.attributes);
  swap(a.durability, b.durability);
  swap(a.__isset, b.__isset);
}

TTableDescriptor::TTableDescriptor(const TTableDescriptor& other193) {
  tableName = other193.tableName;
  columns = other193.columns;
  attributes = other193.attributes;
  durability = other193.durability;
  __isset = other193.__isset;
}
TTableDescriptor& TTableDescriptor::operator=(const TTableDescriptor& other194) {
  tableName = other194.tableName;
  columns = other194.columns;
  attributes = other194.attributes;
  durability = other194.durability;
  __isset = other194.__isset;
  return *this;
}
std::ostream& operator<<(std::ostream& out, const TTableDescriptor& obj) {
  using apache::thrift::to_string;
  out << "TTableDescriptor(";
  out << "tableName=" << to_string(obj.tableName);
  out << ", " << "columns="; (obj.__isset.columns ? (out << to_string(obj.columns)) : (out << "<null>"));
  out << ", " << "attributes="; (obj.__isset.attributes ? (out << to_string(obj.attributes)) : (out << "<null>"));
  out << ", " << "durability="; (obj.__isset.durability ? (out << to_string(obj.durability)) : (out << "<null>"));
  out << ")";
  return out;
}


TNamespaceDescriptor::~TNamespaceDescriptor() throw() {
}


void TNamespaceDescriptor::__set_name(const std::string& val) {
  this->name = val;
}

void TNamespaceDescriptor::__set_configuration(const std::map<std::string, std::string> & val) {
  this->configuration = val;
__isset.configuration = true;
}

const char* TNamespaceDescriptor::ascii_fingerprint = "31FBBEA1FC165CE500F2DE705C5C27CE";
const uint8_t TNamespaceDescriptor::binary_fingerprint[16] = {0x31,0xFB,0xBE,0xA1,0xFC,0x16,0x5C,0xE5,0x00,0xF2,0xDE,0x70,0x5C,0x5C,0x27,0xCE};

uint32_t TNamespaceDescriptor::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_name = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->name);
          isset_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->configuration.clear();
            uint32_t _size195;
            ::apache::thrift::protocol::TType _ktype196;
            ::apache::thrift::protocol::TType _vtype197;
            xfer += iprot->readMapBegin(_ktype196, _vtype197, _size195);
            uint32_t _i199;
            for (_i199 = 0; _i199 < _size195; ++_i199)
            {
              std::string _key200;
              xfer += iprot->readString(_key200);
              std::string& _val201 = this->configuration[_key200];
              xfer += iprot->readString(_val201);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.configuration = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_name)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TNamespaceDescriptor::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  oprot->incrementRecursionDepth();
  xfer += oprot->writeStructBegin("TNamespaceDescriptor");

  xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->name);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.configuration) {
    xfer += oprot->writeFieldBegin("configuration", ::apache::thrift::protocol::T_MAP, 2);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->configuration.size()));
      std::map<std::string, std::string> ::const_iterator _iter202;
      for (_iter202 = this->configuration.begin(); _iter202 != this->configuration.end(); ++_iter202)
      {
        xfer += oprot->writeString(_iter202->first);
        xfer += oprot->writeString(_iter202->second);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  oprot->decrementRecursionDepth();
  return xfer;
}

void swap(TNamespaceDescriptor &a, TNamespaceDescriptor &b) {
  using ::std::swap;
  swap(a.name, b.name);
  swap(a.configuration, b.configuration);
  swap(a.__isset, b.__isset);
}

TNamespaceDescriptor::TNamespaceDescriptor(const TNamespaceDescriptor& other203) {
  name = other203.name;
  configuration = other203.configuration;
  __isset = other203.__isset;
}
TNamespaceDescriptor& TNamespaceDescriptor::operator=(const TNamespaceDescriptor& other204) {
  name = other204.name;
  configuration = other204.configuration;
  __isset = other204.__isset;
  return *this;
}
std::ostream& operator<<(std::ostream& out, const TNamespaceDescriptor& obj) {
  using apache::thrift::to_string;
  out << "TNamespaceDescriptor(";
  out << "name=" << to_string(obj.name);
  out << ", " << "configuration="; (obj.__isset.configuration ? (out << to_string(obj.configuration)) : (out << "<null>"));
  out << ")";
  return out;
}


TLogQueryFilter::~TLogQueryFilter() throw() {
}


void TLogQueryFilter::__set_regionName(const std::string& val) {
  this->regionName = val;
__isset.regionName = true;
}

void TLogQueryFilter::__set_clientAddress(const std::string& val) {
  this->clientAddress = val;
__isset.clientAddress = true;
}

void TLogQueryFilter::__set_tableName(const std::string& val) {
  this->tableName = val;
__isset.tableName = true;
}

void TLogQueryFilter::__set_userName(const std::string& val) {
  this->userName = val;
__isset.userName = true;
}

void TLogQueryFilter::__set_limit(const int32_t val) {
  this->limit = val;
__isset.limit = true;
}

void TLogQueryFilter::__set_logType(const TLogType::type val) {
  this->logType = val;
__isset.logType = true;
}

void TLogQueryFilter::__set_filterByOperator(const TFilterByOperator::type val) {
  this->filterByOperator = val;
__isset.filterByOperator = true;
}

const char* TLogQueryFilter::ascii_fingerprint = "76D4A6CC4FBEF0BF5B09853ED97160E9";
const uint8_t TLogQueryFilter::binary_fingerprint[16] = {0x76,0xD4,0xA6,0xCC,0x4F,0xBE,0xF0,0xBF,0x5B,0x09,0x85,0x3E,0xD9,0x71,0x60,0xE9};

uint32_t TLogQueryFilter::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->regionName);
          this->__isset.regionName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->clientAddress);
          this->__isset.clientAddress = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->tableName);
          this->__isset.tableName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->userName);
          this->__isset.userName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->limit);
          this->__isset.limit = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast205;
          xfer += iprot->readI32(ecast205);
          this->logType = (TLogType::type)ecast205;
          this->__isset.logType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast206;
          xfer += iprot->readI32(ecast206);
          this->filterByOperator = (TFilterByOperator::type)ecast206;
          this->__isset.filterByOperator = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TLogQueryFilter::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  oprot->incrementRecursionDepth();
  xfer += oprot->writeStructBegin("TLogQueryFilter");

  if (this->__isset.regionName) {
    xfer += oprot->writeFieldBegin("regionName", ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot->writeString(this->regionName);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.clientAddress) {
    xfer += oprot->writeFieldBegin("clientAddress", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->clientAddress);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.tableName) {
    xfer += oprot->writeFieldBegin("tableName", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeString(this->tableName);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.userName) {
    xfer += oprot->writeFieldBegin("userName", ::apache::thrift::protocol::T_STRING, 4);
    xfer += oprot->writeString(this->userName);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.limit) {
    xfer += oprot->writeFieldBegin("limit", ::apache::thrift::protocol::T_I32, 5);
    xfer += oprot->writeI32(this->limit);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.logType) {
    xfer += oprot->writeFieldBegin("logType", ::apache::thrift::protocol::T_I32, 6);
    xfer += oprot->writeI32((int32_t)this->logType);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.filterByOperator) {
    xfer += oprot->writeFieldBegin("filterByOperator", ::apache::thrift::protocol::T_I32, 7);
    xfer += oprot->writeI32((int32_t)this->filterByOperator);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  oprot->decrementRecursionDepth();
  return xfer;
}

void swap(TLogQueryFilter &a, TLogQueryFilter &b) {
  using ::std::swap;
  swap(a.regionName, b.regionName);
  swap(a.clientAddress, b.clientAddress);
  swap(a.tableName, b.tableName);
  swap(a.userName, b.userName);
  swap(a.limit, b.limit);
  swap(a.logType, b.logType);
  swap(a.filterByOperator, b.filterByOperator);
  swap(a.__isset, b.__isset);
}

TLogQueryFilter::TLogQueryFilter(const TLogQueryFilter& other207) {
  regionName = other207.regionName;
  clientAddress = other207.clientAddress;
  tableName = other207.tableName;
  userName = other207.userName;
  limit = other207.limit;
  logType = other207.logType;
  filterByOperator = other207.filterByOperator;
  __isset = other207.__isset;
}
TLogQueryFilter& TLogQueryFilter::operator=(const TLogQueryFilter& other208) {
  regionName = other208.regionName;
  clientAddress = other208.clientAddress;
  tableName = other208.tableName;
  userName = other208.userName;
  limit = other208.limit;
  logType = other208.logType;
  filterByOperator = other208.filterByOperator;
  __isset = other208.__isset;
  return *this;
}
std::ostream& operator<<(std::ostream& out, const TLogQueryFilter& obj) {
  using apache::thrift::to_string;
  out << "TLogQueryFilter(";
  out << "regionName="; (obj.__isset.regionName ? (out << to_string(obj.regionName)) : (out << "<null>"));
  out << ", " << "clientAddress="; (obj.__isset.clientAddress ? (out << to_string(obj.clientAddress)) : (out << "<null>"));
  out << ", " << "tableName="; (obj.__isset.tableName ? (out << to_string(obj.tableName)) : (out << "<null>"));
  out << ", " << "userName="; (obj.__isset.userName ? (out << to_string(obj.userName)) : (out << "<null>"));
  out << ", " << "limit="; (obj.__isset.limit ? (out << to_string(obj.limit)) : (out << "<null>"));
  out << ", " << "logType="; (obj.__isset.logType ? (out << to_string(obj.logType)) : (out << "<null>"));
  out << ", " << "filterByOperator="; (obj.__isset.filterByOperator ? (out << to_string(obj.filterByOperator)) : (out << "<null>"));
  out << ")";
  return out;
}


TOnlineLogRecord::~TOnlineLogRecord() throw() {
}


void TOnlineLogRecord::__set_startTime(const int64_t val) {
  this->startTime = val;
}

void TOnlineLogRecord::__set_processingTime(const int32_t val) {
  this->processingTime = val;
}

void TOnlineLogRecord::__set_queueTime(const int32_t val) {
  this->queueTime = val;
}

void TOnlineLogRecord::__set_responseSize(const int64_t val) {
  this->responseSize = val;
}

void TOnlineLogRecord::__set_clientAddress(const std::string& val) {
  this->clientAddress = val;
}

void TOnlineLogRecord::__set_serverClass(const std::string& val) {
  this->serverClass = val;
}

void TOnlineLogRecord::__set_methodName(const std::string& val) {
  this->methodName = val;
}

void TOnlineLogRecord::__set_callDetails(const std::string& val) {
  this->callDetails = val;
}

void TOnlineLogRecord::__set_param(const std::string& val) {
  this->param = val;
}

void TOnlineLogRecord::__set_userName(const std::string& val) {
  this->userName = val;
}

void TOnlineLogRecord::__set_multiGetsCount(const int32_t val) {
  this->multiGetsCount = val;
}

void TOnlineLogRecord::__set_multiMutationsCount(const int32_t val) {
  this->multiMutationsCount = val;
}

void TOnlineLogRecord::__set_multiServiceCalls(const int32_t val) {
  this->multiServiceCalls = val;
}

void TOnlineLogRecord::__set_regionName(const std::string& val) {
  this->regionName = val;
__isset.regionName = true;
}

const char* TOnlineLogRecord::ascii_fingerprint = "04CC55DC4A0AC369E51739AC731025D8";
const uint8_t TOnlineLogRecord::binary_fingerprint[16] = {0x04,0xCC,0x55,0xDC,0x4A,0x0A,0xC3,0x69,0xE5,0x17,0x39,0xAC,0x73,0x10,0x25,0xD8};

uint32_t TOnlineLogRecord::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_startTime = false;
  bool isset_processingTime = false;
  bool isset_queueTime = false;
  bool isset_responseSize = false;
  bool isset_clientAddress = false;
  bool isset_serverClass = false;
  bool isset_methodName = false;
  bool isset_callDetails = false;
  bool isset_param = false;
  bool isset_userName = false;
  bool isset_multiGetsCount = false;
  bool isset_multiMutationsCount = false;
  bool isset_multiServiceCalls = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->startTime);
          isset_startTime = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->processingTime);
          isset_processingTime = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->queueTime);
          isset_queueTime = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->responseSize);
          isset_responseSize = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->clientAddress);
          isset_clientAddress = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->serverClass);
          isset_serverClass = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->methodName);
          isset_methodName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->callDetails);
          isset_callDetails = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->param);
          isset_param = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->userName);
          isset_userName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->multiGetsCount);
          isset_multiGetsCount = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 12:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->multiMutationsCount);
          isset_multiMutationsCount = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 13:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->multiServiceCalls);
          isset_multiServiceCalls = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 14:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->regionName);
          this->__isset.regionName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_startTime)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_processingTime)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_queueTime)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_responseSize)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_clientAddress)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_serverClass)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_methodName)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_callDetails)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_param)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_userName)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_multiGetsCount)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_multiMutationsCount)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_multiServiceCalls)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TOnlineLogRecord::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  oprot->incrementRecursionDepth();
  xfer += oprot->writeStructBegin("TOnlineLogRecord");

  xfer += oprot->writeFieldBegin("startTime", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->startTime);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("processingTime", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->processingTime);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("queueTime", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->queueTime);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("responseSize", ::apache::thrift::protocol::T_I64, 4);
  xfer += oprot->writeI64(this->responseSize);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("clientAddress", ::apache::thrift::protocol::T_STRING, 5);
  xfer += oprot->writeString(this->clientAddress);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("serverClass", ::apache::thrift::protocol::T_STRING, 6);
  xfer += oprot->writeString(this->serverClass);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("methodName", ::apache::thrift::protocol::T_STRING, 7);
  xfer += oprot->writeString(this->methodName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("callDetails", ::apache::thrift::protocol::T_STRING, 8);
  xfer += oprot->writeString(this->callDetails);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("param", ::apache::thrift::protocol::T_STRING, 9);
  xfer += oprot->writeString(this->param);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("userName", ::apache::thrift::protocol::T_STRING, 10);
  xfer += oprot->writeString(this->userName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("multiGetsCount", ::apache::thrift::protocol::T_I32, 11);
  xfer += oprot->writeI32(this->multiGetsCount);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("multiMutationsCount", ::apache::thrift::protocol::T_I32, 12);
  xfer += oprot->writeI32(this->multiMutationsCount);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("multiServiceCalls", ::apache::thrift::protocol::T_I32, 13);
  xfer += oprot->writeI32(this->multiServiceCalls);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.regionName) {
    xfer += oprot->writeFieldBegin("regionName", ::apache::thrift::protocol::T_STRING, 14);
    xfer += oprot->writeString(this->regionName);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  oprot->decrementRecursionDepth();
  return xfer;
}

void swap(TOnlineLogRecord &a, TOnlineLogRecord &b) {
  using ::std::swap;
  swap(a.startTime, b.startTime);
  swap(a.processingTime, b.processingTime);
  swap(a.queueTime, b.queueTime);
  swap(a.responseSize, b.responseSize);
  swap(a.clientAddress, b.clientAddress);
  swap(a.serverClass, b.serverClass);
  swap(a.methodName, b.methodName);
  swap(a.callDetails, b.callDetails);
  swap(a.param, b.param);
  swap(a.userName, b.userName);
  swap(a.multiGetsCount, b.multiGetsCount);
  swap(a.multiMutationsCount, b.multiMutationsCount);
  swap(a.multiServiceCalls, b.multiServiceCalls);
  swap(a.regionName, b.regionName);
  swap(a.__isset, b.__isset);
}

TOnlineLogRecord::TOnlineLogRecord(const TOnlineLogRecord& other209) {
  startTime = other209.startTime;
  processingTime = other209.processingTime;
  queueTime = other209.queueTime;
  responseSize = other209.responseSize;
  clientAddress = other209.clientAddress;
  serverClass = other209.serverClass;
  methodName = other209.methodName;
  callDetails = other209.callDetails;
  param = other209.param;
  userName = other209.userName;
  multiGetsCount = other209.multiGetsCount;
  multiMutationsCount = other209.multiMutationsCount;
  multiServiceCalls = other209.multiServiceCalls;
  regionName = other209.regionName;
  __isset = other209.__isset;
}
TOnlineLogRecord& TOnlineLogRecord::operator=(const TOnlineLogRecord& other210) {
  startTime = other210.startTime;
  processingTime = other210.processingTime;
  queueTime = other210.queueTime;
  responseSize = other210.responseSize;
  clientAddress = other210.clientAddress;
  serverClass = other210.serverClass;
  methodName = other210.methodName;
  callDetails = other210.callDetails;
  param = other210.param;
  userName = other210.userName;
  multiGetsCount = other210.multiGetsCount;
  multiMutationsCount = other210.multiMutationsCount;
  multiServiceCalls = other210.multiServiceCalls;
  regionName = other210.regionName;
  __isset = other210.__isset;
  return *this;
}
std::ostream& operator<<(std::ostream& out, const TOnlineLogRecord& obj) {
  using apache::thrift::to_string;
  out << "TOnlineLogRecord(";
  out << "startTime=" << to_string(obj.startTime);
  out << ", " << "processingTime=" << to_string(obj.processingTime);
  out << ", " << "queueTime=" << to_string(obj.queueTime);
  out << ", " << "responseSize=" << to_string(obj.responseSize);
  out << ", " << "clientAddress=" << to_string(obj.clientAddress);
  out << ", " << "serverClass=" << to_string(obj.serverClass);
  out << ", " << "methodName=" << to_string(obj.methodName);
  out << ", " << "callDetails=" << to_string(obj.callDetails);
  out << ", " << "param=" << to_string(obj.param);
  out << ", " << "userName=" << to_string(obj.userName);
  out << ", " << "multiGetsCount=" << to_string(obj.multiGetsCount);
  out << ", " << "multiMutationsCount=" << to_string(obj.multiMutationsCount);
  out << ", " << "multiServiceCalls=" << to_string(obj.multiServiceCalls);
  out << ", " << "regionName="; (obj.__isset.regionName ? (out << to_string(obj.regionName)) : (out << "<null>"));
  out << ")";
  return out;
}


TIOError::~TIOError() throw() {
}


void TIOError::__set_message(const std::string& val) {
  this->message = val;
__isset.message = true;
}

void TIOError::__set_canRetry(const bool val) {
  this->canRetry = val;
__isset.canRetry = true;
}

const char* TIOError::ascii_fingerprint = "6200BB33D161C25E4ABCC4E5B0FB2883";
const uint8_t TIOError::binary_fingerprint[16] = {0x62,0x00,0xBB,0x33,0xD1,0x61,0xC2,0x5E,0x4A,0xBC,0xC4,0xE5,0xB0,0xFB,0x28,0x83};

uint32_t TIOError::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->message);
          this->__isset.message = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->canRetry);
          this->__isset.canRetry = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TIOError::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  oprot->incrementRecursionDepth();
  xfer += oprot->writeStructBegin("TIOError");

  if (this->__isset.message) {
    xfer += oprot->writeFieldBegin("message", ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot->writeString(this->message);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.canRetry) {
    xfer += oprot->writeFieldBegin("canRetry", ::apache::thrift::protocol::T_BOOL, 2);
    xfer += oprot->writeBool(this->canRetry);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  oprot->decrementRecursionDepth();
  return xfer;
}

void swap(TIOError &a, TIOError &b) {
  using ::std::swap;
  swap(a.message, b.message);
  swap(a.canRetry, b.canRetry);
  swap(a.__isset, b.__isset);
}

TIOError::TIOError(const TIOError& other211) : TException() {
  message = other211.message;
  canRetry = other211.canRetry;
  __isset = other211.__isset;
}
TIOError& TIOError::operator=(const TIOError& other212) {
  message = other212.message;
  canRetry = other212.canRetry;
  __isset = other212.__isset;
  return *this;
}
std::ostream& operator<<(std::ostream& out, const TIOError& obj) {
  using apache::thrift::to_string;
  out << "TIOError(";
  out << "message="; (obj.__isset.message ? (out << to_string(obj.message)) : (out << "<null>"));
  out << ", " << "canRetry="; (obj.__isset.canRetry ? (out << to_string(obj.canRetry)) : (out << "<null>"));
  out << ")";
  return out;
}


TIllegalArgument::~TIllegalArgument() throw() {
}


void TIllegalArgument::__set_message(const std::string& val) {
  this->message = val;
__isset.message = true;
}

const char* TIllegalArgument::ascii_fingerprint = "66E694018C17E5B65A59AE8F55CCA3CD";
const uint8_t TIllegalArgument::binary_fingerprint[16] = {0x66,0xE6,0x94,0x01,0x8C,0x17,0xE5,0xB6,0x5A,0x59,0xAE,0x8F,0x55,0xCC,0xA3,0xCD};

uint32_t TIllegalArgument::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->message);
          this->__isset.message = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TIllegalArgument::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  oprot->incrementRecursionDepth();
  xfer += oprot->writeStructBegin("TIllegalArgument");

  if (this->__isset.message) {
    xfer += oprot->writeFieldBegin("message", ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot->writeString(this->message);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  oprot->decrementRecursionDepth();
  return xfer;
}

void swap(TIllegalArgument &a, TIllegalArgument &b) {
  using ::std::swap;
  swap(a.message, b.message);
  swap(a.__isset, b.__isset);
}

TIllegalArgument::TIllegalArgument(const TIllegalArgument& other213) : TException() {
  message = other213.message;
  __isset = other213.__isset;
}
TIllegalArgument& TIllegalArgument::operator=(const TIllegalArgument& other214) {
  message = other214.message;
  __isset = other214.__isset;
  return *this;
}
std::ostream& operator<<(std::ostream& out, const TIllegalArgument& obj) {
  using apache::thrift::to_string;
  out << "TIllegalArgument(";
  out << "message="; (obj.__isset.message ? (out << to_string(obj.message)) : (out << "<null>"));
  out << ")";
  return out;
}

}}}} // namespace
