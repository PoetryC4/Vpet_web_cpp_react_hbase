/**
 * Autogenerated by Thrift Compiler (0.9.2)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#ifndef hbase_TYPES_H
#define hbase_TYPES_H

#include <iosfwd>

#include <thrift/Thrift.h>
#include <thrift/TApplicationException.h>
#include <thrift/protocol/TProtocol.h>
#include <thrift/transport/TTransport.h>

#include <thrift/cxxfunctional.h>


namespace apache { namespace hadoop { namespace hbase { namespace thrift2 {

struct TDeleteType {
  enum type {
    DELETE_COLUMN = 0,
    DELETE_COLUMNS = 1,
    DELETE_FAMILY = 2,
    DELETE_FAMILY_VERSION = 3
  };
};

extern const std::map<int, const char*> _TDeleteType_VALUES_TO_NAMES;

struct TDurability {
  enum type {
    USE_DEFAULT = 0,
    SKIP_WAL = 1,
    ASYNC_WAL = 2,
    SYNC_WAL = 3,
    FSYNC_WAL = 4
  };
};

extern const std::map<int, const char*> _TDurability_VALUES_TO_NAMES;

struct TConsistency {
  enum type {
    STRONG = 1,
    TIMELINE = 2
  };
};

extern const std::map<int, const char*> _TConsistency_VALUES_TO_NAMES;

struct TReadType {
  enum type {
    DEFAULT = 1,
    STREAM = 2,
    PREAD = 3
  };
};

extern const std::map<int, const char*> _TReadType_VALUES_TO_NAMES;

struct TCompareOp {
  enum type {
    LESS = 0,
    LESS_OR_EQUAL = 1,
    EQUAL = 2,
    NOT_EQUAL = 3,
    GREATER_OR_EQUAL = 4,
    GREATER = 5,
    NO_OP = 6
  };
};

extern const std::map<int, const char*> _TCompareOp_VALUES_TO_NAMES;

struct TBloomFilterType {
  enum type {
    NONE = 0,
    ROW = 1,
    ROWCOL = 2,
    ROWPREFIX_FIXED_LENGTH = 3
  };
};

extern const std::map<int, const char*> _TBloomFilterType_VALUES_TO_NAMES;

struct TCompressionAlgorithm {
  enum type {
    LZO = 0,
    GZ = 1,
    NONE = 2,
    SNAPPY = 3,
    LZ4 = 4,
    BZIP2 = 5,
    ZSTD = 6
  };
};

extern const std::map<int, const char*> _TCompressionAlgorithm_VALUES_TO_NAMES;

struct TDataBlockEncoding {
  enum type {
    NONE = 0,
    PREFIX = 2,
    DIFF = 3,
    FAST_DIFF = 4,
    ROW_INDEX_V1 = 7
  };
};

extern const std::map<int, const char*> _TDataBlockEncoding_VALUES_TO_NAMES;

struct TKeepDeletedCells {
  enum type {
    FALSE = 0,
    TRUE = 1,
    TTL = 2
  };
};

extern const std::map<int, const char*> _TKeepDeletedCells_VALUES_TO_NAMES;

struct TLogType {
  enum type {
    SLOW_LOG = 1,
    LARGE_LOG = 2
  };
};

extern const std::map<int, const char*> _TLogType_VALUES_TO_NAMES;

struct TFilterByOperator {
  enum type {
    AND = 0,
    OR = 1
  };
};

extern const std::map<int, const char*> _TFilterByOperator_VALUES_TO_NAMES;

struct TThriftServerType {
  enum type {
    ONE = 1,
    TWO = 2
  };
};

extern const std::map<int, const char*> _TThriftServerType_VALUES_TO_NAMES;

class TTimeRange;

class TColumn;

class TColumnValue;

class TColumnIncrement;

class TResult;

class TAuthorization;

class TCellVisibility;

class TGet;

class TPut;

class TDelete;

class TIncrement;

class TAppend;

class TScan;

class TMutation;

class TRowMutations;

class THRegionInfo;

class TServerName;

class THRegionLocation;

class TTableName;

class TColumnFamilyDescriptor;

class TTableDescriptor;

class TNamespaceDescriptor;

class TLogQueryFilter;

class TOnlineLogRecord;

class TIOError;

class TIllegalArgument;


class TTimeRange {
 public:

  static const char* ascii_fingerprint; // = "F33135321253DAEB67B0E79E416CA831";
  static const uint8_t binary_fingerprint[16]; // = {0xF3,0x31,0x35,0x32,0x12,0x53,0xDA,0xEB,0x67,0xB0,0xE7,0x9E,0x41,0x6C,0xA8,0x31};

  TTimeRange(const TTimeRange&);
  TTimeRange& operator=(const TTimeRange&);
  TTimeRange() : minStamp(0), maxStamp(0) {
  }

  virtual ~TTimeRange() throw();
  int64_t minStamp;
  int64_t maxStamp;

  void __set_minStamp(const int64_t val);

  void __set_maxStamp(const int64_t val);

  bool operator == (const TTimeRange & rhs) const
  {
    if (!(minStamp == rhs.minStamp))
      return false;
    if (!(maxStamp == rhs.maxStamp))
      return false;
    return true;
  }
  bool operator != (const TTimeRange &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TTimeRange & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const TTimeRange& obj);
};

void swap(TTimeRange &a, TTimeRange &b);

typedef struct _TColumn__isset {
  _TColumn__isset() : qualifier(false), timestamp(false) {}
  bool qualifier :1;
  bool timestamp :1;
} _TColumn__isset;

class TColumn {
 public:

  static const char* ascii_fingerprint; // = "354B89A42CE318BBBCE588A386D5D6CD";
  static const uint8_t binary_fingerprint[16]; // = {0x35,0x4B,0x89,0xA4,0x2C,0xE3,0x18,0xBB,0xBC,0xE5,0x88,0xA3,0x86,0xD5,0xD6,0xCD};

  TColumn(const TColumn&);
  TColumn& operator=(const TColumn&);
  TColumn() : family(), qualifier(), timestamp(0) {
  }

  virtual ~TColumn() throw();
  std::string family;
  std::string qualifier;
  int64_t timestamp;

  _TColumn__isset __isset;

  void __set_family(const std::string& val);

  void __set_qualifier(const std::string& val);

  void __set_timestamp(const int64_t val);

  bool operator == (const TColumn & rhs) const
  {
    if (!(family == rhs.family))
      return false;
    if (__isset.qualifier != rhs.__isset.qualifier)
      return false;
    else if (__isset.qualifier && !(qualifier == rhs.qualifier))
      return false;
    if (__isset.timestamp != rhs.__isset.timestamp)
      return false;
    else if (__isset.timestamp && !(timestamp == rhs.timestamp))
      return false;
    return true;
  }
  bool operator != (const TColumn &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TColumn & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const TColumn& obj);
};

void swap(TColumn &a, TColumn &b);

typedef struct _TColumnValue__isset {
  _TColumnValue__isset() : timestamp(false), tags(false), type(false) {}
  bool timestamp :1;
  bool tags :1;
  bool type :1;
} _TColumnValue__isset;

class TColumnValue {
 public:

  static const char* ascii_fingerprint; // = "65C351854DFBF62D6B2BCFB2FA804844";
  static const uint8_t binary_fingerprint[16]; // = {0x65,0xC3,0x51,0x85,0x4D,0xFB,0xF6,0x2D,0x6B,0x2B,0xCF,0xB2,0xFA,0x80,0x48,0x44};

  TColumnValue(const TColumnValue&);
  TColumnValue& operator=(const TColumnValue&);
  TColumnValue() : family(), qualifier(), value(), timestamp(0), tags(), type(0) {
  }

  virtual ~TColumnValue() throw();
  std::string family;
  std::string qualifier;
  std::string value;
  int64_t timestamp;
  std::string tags;
  int8_t type;

  _TColumnValue__isset __isset;

  void __set_family(const std::string& val);

  void __set_qualifier(const std::string& val);

  void __set_value(const std::string& val);

  void __set_timestamp(const int64_t val);

  void __set_tags(const std::string& val);

  void __set_type(const int8_t val);

  bool operator == (const TColumnValue & rhs) const
  {
    if (!(family == rhs.family))
      return false;
    if (!(qualifier == rhs.qualifier))
      return false;
    if (!(value == rhs.value))
      return false;
    if (__isset.timestamp != rhs.__isset.timestamp)
      return false;
    else if (__isset.timestamp && !(timestamp == rhs.timestamp))
      return false;
    if (__isset.tags != rhs.__isset.tags)
      return false;
    else if (__isset.tags && !(tags == rhs.tags))
      return false;
    if (__isset.type != rhs.__isset.type)
      return false;
    else if (__isset.type && !(type == rhs.type))
      return false;
    return true;
  }
  bool operator != (const TColumnValue &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TColumnValue & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const TColumnValue& obj);
};

void swap(TColumnValue &a, TColumnValue &b);

typedef struct _TColumnIncrement__isset {
  _TColumnIncrement__isset() : amount(true) {}
  bool amount :1;
} _TColumnIncrement__isset;

class TColumnIncrement {
 public:

  static const char* ascii_fingerprint; // = "C55F1CDA80E5E1836AFA7E590331D0A5";
  static const uint8_t binary_fingerprint[16]; // = {0xC5,0x5F,0x1C,0xDA,0x80,0xE5,0xE1,0x83,0x6A,0xFA,0x7E,0x59,0x03,0x31,0xD0,0xA5};

  TColumnIncrement(const TColumnIncrement&);
  TColumnIncrement& operator=(const TColumnIncrement&);
  TColumnIncrement() : family(), qualifier(), amount(1LL) {
  }

  virtual ~TColumnIncrement() throw();
  std::string family;
  std::string qualifier;
  int64_t amount;

  _TColumnIncrement__isset __isset;

  void __set_family(const std::string& val);

  void __set_qualifier(const std::string& val);

  void __set_amount(const int64_t val);

  bool operator == (const TColumnIncrement & rhs) const
  {
    if (!(family == rhs.family))
      return false;
    if (!(qualifier == rhs.qualifier))
      return false;
    if (__isset.amount != rhs.__isset.amount)
      return false;
    else if (__isset.amount && !(amount == rhs.amount))
      return false;
    return true;
  }
  bool operator != (const TColumnIncrement &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TColumnIncrement & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const TColumnIncrement& obj);
};

void swap(TColumnIncrement &a, TColumnIncrement &b);

typedef struct _TResult__isset {
  _TResult__isset() : row(false), stale(true), partial(true) {}
  bool row :1;
  bool stale :1;
  bool partial :1;
} _TResult__isset;

class TResult {
 public:

  static const char* ascii_fingerprint; // = "ED801A7807FE100E997823D4501A553B";
  static const uint8_t binary_fingerprint[16]; // = {0xED,0x80,0x1A,0x78,0x07,0xFE,0x10,0x0E,0x99,0x78,0x23,0xD4,0x50,0x1A,0x55,0x3B};

  TResult(const TResult&);
  TResult& operator=(const TResult&);
  TResult() : row(), stale(false), partial(false) {
  }

  virtual ~TResult() throw();
  std::string row;
  std::vector<TColumnValue>  columnValues;
  bool stale;
  bool partial;

  _TResult__isset __isset;

  void __set_row(const std::string& val);

  void __set_columnValues(const std::vector<TColumnValue> & val);

  void __set_stale(const bool val);

  void __set_partial(const bool val);

  bool operator == (const TResult & rhs) const
  {
    if (__isset.row != rhs.__isset.row)
      return false;
    else if (__isset.row && !(row == rhs.row))
      return false;
    if (!(columnValues == rhs.columnValues))
      return false;
    if (__isset.stale != rhs.__isset.stale)
      return false;
    else if (__isset.stale && !(stale == rhs.stale))
      return false;
    if (__isset.partial != rhs.__isset.partial)
      return false;
    else if (__isset.partial && !(partial == rhs.partial))
      return false;
    return true;
  }
  bool operator != (const TResult &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TResult & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const TResult& obj);
};

void swap(TResult &a, TResult &b);

typedef struct _TAuthorization__isset {
  _TAuthorization__isset() : labels(false) {}
  bool labels :1;
} _TAuthorization__isset;

class TAuthorization {
 public:

  static const char* ascii_fingerprint; // = "6A3474ADDA840BE2091105F0DFB630C7";
  static const uint8_t binary_fingerprint[16]; // = {0x6A,0x34,0x74,0xAD,0xDA,0x84,0x0B,0xE2,0x09,0x11,0x05,0xF0,0xDF,0xB6,0x30,0xC7};

  TAuthorization(const TAuthorization&);
  TAuthorization& operator=(const TAuthorization&);
  TAuthorization() {
  }

  virtual ~TAuthorization() throw();
  std::vector<std::string>  labels;

  _TAuthorization__isset __isset;

  void __set_labels(const std::vector<std::string> & val);

  bool operator == (const TAuthorization & rhs) const
  {
    if (__isset.labels != rhs.__isset.labels)
      return false;
    else if (__isset.labels && !(labels == rhs.labels))
      return false;
    return true;
  }
  bool operator != (const TAuthorization &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TAuthorization & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const TAuthorization& obj);
};

void swap(TAuthorization &a, TAuthorization &b);

typedef struct _TCellVisibility__isset {
  _TCellVisibility__isset() : expression(false) {}
  bool expression :1;
} _TCellVisibility__isset;

class TCellVisibility {
 public:

  static const char* ascii_fingerprint; // = "66E694018C17E5B65A59AE8F55CCA3CD";
  static const uint8_t binary_fingerprint[16]; // = {0x66,0xE6,0x94,0x01,0x8C,0x17,0xE5,0xB6,0x5A,0x59,0xAE,0x8F,0x55,0xCC,0xA3,0xCD};

  TCellVisibility(const TCellVisibility&);
  TCellVisibility& operator=(const TCellVisibility&);
  TCellVisibility() : expression() {
  }

  virtual ~TCellVisibility() throw();
  std::string expression;

  _TCellVisibility__isset __isset;

  void __set_expression(const std::string& val);

  bool operator == (const TCellVisibility & rhs) const
  {
    if (__isset.expression != rhs.__isset.expression)
      return false;
    else if (__isset.expression && !(expression == rhs.expression))
      return false;
    return true;
  }
  bool operator != (const TCellVisibility &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TCellVisibility & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const TCellVisibility& obj);
};

void swap(TCellVisibility &a, TCellVisibility &b);

typedef struct _TGet__isset {
  _TGet__isset() : columns(false), timestamp(false), timeRange(false), maxVersions(false), filterString(false), attributes(false), authorizations(false), consistency(false), targetReplicaId(false), cacheBlocks(false), storeLimit(false), storeOffset(false), existence_only(false), filterBytes(false) {}
  bool columns :1;
  bool timestamp :1;
  bool timeRange :1;
  bool maxVersions :1;
  bool filterString :1;
  bool attributes :1;
  bool authorizations :1;
  bool consistency :1;
  bool targetReplicaId :1;
  bool cacheBlocks :1;
  bool storeLimit :1;
  bool storeOffset :1;
  bool existence_only :1;
  bool filterBytes :1;
} _TGet__isset;

class TGet {
 public:

  static const char* ascii_fingerprint; // = "EC3FAE31621A7A6F276FABD32EF03CDA";
  static const uint8_t binary_fingerprint[16]; // = {0xEC,0x3F,0xAE,0x31,0x62,0x1A,0x7A,0x6F,0x27,0x6F,0xAB,0xD3,0x2E,0xF0,0x3C,0xDA};

  TGet(const TGet&);
  TGet& operator=(const TGet&);
  TGet() : row(), timestamp(0), maxVersions(0), filterString(), consistency((TConsistency::type)0), targetReplicaId(0), cacheBlocks(0), storeLimit(0), storeOffset(0), existence_only(0), filterBytes() {
  }

  virtual ~TGet() throw();
  std::string row;
  std::vector<TColumn>  columns;
  int64_t timestamp;
  TTimeRange timeRange;
  int32_t maxVersions;
  std::string filterString;
  std::map<std::string, std::string>  attributes;
  TAuthorization authorizations;
  TConsistency::type consistency;
  int32_t targetReplicaId;
  bool cacheBlocks;
  int32_t storeLimit;
  int32_t storeOffset;
  bool existence_only;
  std::string filterBytes;

  _TGet__isset __isset;

  void __set_row(const std::string& val);

  void __set_columns(const std::vector<TColumn> & val);

  void __set_timestamp(const int64_t val);

  void __set_timeRange(const TTimeRange& val);

  void __set_maxVersions(const int32_t val);

  void __set_filterString(const std::string& val);

  void __set_attributes(const std::map<std::string, std::string> & val);

  void __set_authorizations(const TAuthorization& val);

  void __set_consistency(const TConsistency::type val);

  void __set_targetReplicaId(const int32_t val);

  void __set_cacheBlocks(const bool val);

  void __set_storeLimit(const int32_t val);

  void __set_storeOffset(const int32_t val);

  void __set_existence_only(const bool val);

  void __set_filterBytes(const std::string& val);

  bool operator == (const TGet & rhs) const
  {
    if (!(row == rhs.row))
      return false;
    if (__isset.columns != rhs.__isset.columns)
      return false;
    else if (__isset.columns && !(columns == rhs.columns))
      return false;
    if (__isset.timestamp != rhs.__isset.timestamp)
      return false;
    else if (__isset.timestamp && !(timestamp == rhs.timestamp))
      return false;
    if (__isset.timeRange != rhs.__isset.timeRange)
      return false;
    else if (__isset.timeRange && !(timeRange == rhs.timeRange))
      return false;
    if (__isset.maxVersions != rhs.__isset.maxVersions)
      return false;
    else if (__isset.maxVersions && !(maxVersions == rhs.maxVersions))
      return false;
    if (__isset.filterString != rhs.__isset.filterString)
      return false;
    else if (__isset.filterString && !(filterString == rhs.filterString))
      return false;
    if (__isset.attributes != rhs.__isset.attributes)
      return false;
    else if (__isset.attributes && !(attributes == rhs.attributes))
      return false;
    if (__isset.authorizations != rhs.__isset.authorizations)
      return false;
    else if (__isset.authorizations && !(authorizations == rhs.authorizations))
      return false;
    if (__isset.consistency != rhs.__isset.consistency)
      return false;
    else if (__isset.consistency && !(consistency == rhs.consistency))
      return false;
    if (__isset.targetReplicaId != rhs.__isset.targetReplicaId)
      return false;
    else if (__isset.targetReplicaId && !(targetReplicaId == rhs.targetReplicaId))
      return false;
    if (__isset.cacheBlocks != rhs.__isset.cacheBlocks)
      return false;
    else if (__isset.cacheBlocks && !(cacheBlocks == rhs.cacheBlocks))
      return false;
    if (__isset.storeLimit != rhs.__isset.storeLimit)
      return false;
    else if (__isset.storeLimit && !(storeLimit == rhs.storeLimit))
      return false;
    if (__isset.storeOffset != rhs.__isset.storeOffset)
      return false;
    else if (__isset.storeOffset && !(storeOffset == rhs.storeOffset))
      return false;
    if (__isset.existence_only != rhs.__isset.existence_only)
      return false;
    else if (__isset.existence_only && !(existence_only == rhs.existence_only))
      return false;
    if (__isset.filterBytes != rhs.__isset.filterBytes)
      return false;
    else if (__isset.filterBytes && !(filterBytes == rhs.filterBytes))
      return false;
    return true;
  }
  bool operator != (const TGet &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TGet & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const TGet& obj);
};

void swap(TGet &a, TGet &b);

typedef struct _TPut__isset {
  _TPut__isset() : timestamp(false), attributes(false), durability(false), cellVisibility(false) {}
  bool timestamp :1;
  bool attributes :1;
  bool durability :1;
  bool cellVisibility :1;
} _TPut__isset;

class TPut {
 public:

  static const char* ascii_fingerprint; // = "0F2E9F071BB47BD4F4B360F6C0312550";
  static const uint8_t binary_fingerprint[16]; // = {0x0F,0x2E,0x9F,0x07,0x1B,0xB4,0x7B,0xD4,0xF4,0xB3,0x60,0xF6,0xC0,0x31,0x25,0x50};

  TPut(const TPut&);
  TPut& operator=(const TPut&);
  TPut() : row(), timestamp(0), durability((TDurability::type)0) {
  }

  virtual ~TPut() throw();
  std::string row;
  std::vector<TColumnValue>  columnValues;
  int64_t timestamp;
  std::map<std::string, std::string>  attributes;
  TDurability::type durability;
  TCellVisibility cellVisibility;

  _TPut__isset __isset;

  void __set_row(const std::string& val);

  void __set_columnValues(const std::vector<TColumnValue> & val);

  void __set_timestamp(const int64_t val);

  void __set_attributes(const std::map<std::string, std::string> & val);

  void __set_durability(const TDurability::type val);

  void __set_cellVisibility(const TCellVisibility& val);

  bool operator == (const TPut & rhs) const
  {
    if (!(row == rhs.row))
      return false;
    if (!(columnValues == rhs.columnValues))
      return false;
    if (__isset.timestamp != rhs.__isset.timestamp)
      return false;
    else if (__isset.timestamp && !(timestamp == rhs.timestamp))
      return false;
    if (__isset.attributes != rhs.__isset.attributes)
      return false;
    else if (__isset.attributes && !(attributes == rhs.attributes))
      return false;
    if (__isset.durability != rhs.__isset.durability)
      return false;
    else if (__isset.durability && !(durability == rhs.durability))
      return false;
    if (__isset.cellVisibility != rhs.__isset.cellVisibility)
      return false;
    else if (__isset.cellVisibility && !(cellVisibility == rhs.cellVisibility))
      return false;
    return true;
  }
  bool operator != (const TPut &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TPut & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const TPut& obj);
};

void swap(TPut &a, TPut &b);

typedef struct _TDelete__isset {
  _TDelete__isset() : columns(false), timestamp(false), deleteType(true), attributes(false), durability(false) {}
  bool columns :1;
  bool timestamp :1;
  bool deleteType :1;
  bool attributes :1;
  bool durability :1;
} _TDelete__isset;

class TDelete {
 public:

  static const char* ascii_fingerprint; // = "84640DFE212CEB30848C27DC77C196F0";
  static const uint8_t binary_fingerprint[16]; // = {0x84,0x64,0x0D,0xFE,0x21,0x2C,0xEB,0x30,0x84,0x8C,0x27,0xDC,0x77,0xC1,0x96,0xF0};

  TDelete(const TDelete&);
  TDelete& operator=(const TDelete&);
  TDelete() : row(), timestamp(0), deleteType((TDeleteType::type)1), durability((TDurability::type)0) {
    deleteType = (TDeleteType::type)1;

  }

  virtual ~TDelete() throw();
  std::string row;
  std::vector<TColumn>  columns;
  int64_t timestamp;
  TDeleteType::type deleteType;
  std::map<std::string, std::string>  attributes;
  TDurability::type durability;

  _TDelete__isset __isset;

  void __set_row(const std::string& val);

  void __set_columns(const std::vector<TColumn> & val);

  void __set_timestamp(const int64_t val);

  void __set_deleteType(const TDeleteType::type val);

  void __set_attributes(const std::map<std::string, std::string> & val);

  void __set_durability(const TDurability::type val);

  bool operator == (const TDelete & rhs) const
  {
    if (!(row == rhs.row))
      return false;
    if (__isset.columns != rhs.__isset.columns)
      return false;
    else if (__isset.columns && !(columns == rhs.columns))
      return false;
    if (__isset.timestamp != rhs.__isset.timestamp)
      return false;
    else if (__isset.timestamp && !(timestamp == rhs.timestamp))
      return false;
    if (__isset.deleteType != rhs.__isset.deleteType)
      return false;
    else if (__isset.deleteType && !(deleteType == rhs.deleteType))
      return false;
    if (__isset.attributes != rhs.__isset.attributes)
      return false;
    else if (__isset.attributes && !(attributes == rhs.attributes))
      return false;
    if (__isset.durability != rhs.__isset.durability)
      return false;
    else if (__isset.durability && !(durability == rhs.durability))
      return false;
    return true;
  }
  bool operator != (const TDelete &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TDelete & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const TDelete& obj);
};

void swap(TDelete &a, TDelete &b);

typedef struct _TIncrement__isset {
  _TIncrement__isset() : attributes(false), durability(false), cellVisibility(false), returnResults(false) {}
  bool attributes :1;
  bool durability :1;
  bool cellVisibility :1;
  bool returnResults :1;
} _TIncrement__isset;

class TIncrement {
 public:

  static const char* ascii_fingerprint; // = "31146EBCF1F761ADE4552E104DAD4CFB";
  static const uint8_t binary_fingerprint[16]; // = {0x31,0x14,0x6E,0xBC,0xF1,0xF7,0x61,0xAD,0xE4,0x55,0x2E,0x10,0x4D,0xAD,0x4C,0xFB};

  TIncrement(const TIncrement&);
  TIncrement& operator=(const TIncrement&);
  TIncrement() : row(), durability((TDurability::type)0), returnResults(0) {
  }

  virtual ~TIncrement() throw();
  std::string row;
  std::vector<TColumnIncrement>  columns;
  std::map<std::string, std::string>  attributes;
  TDurability::type durability;
  TCellVisibility cellVisibility;
  bool returnResults;

  _TIncrement__isset __isset;

  void __set_row(const std::string& val);

  void __set_columns(const std::vector<TColumnIncrement> & val);

  void __set_attributes(const std::map<std::string, std::string> & val);

  void __set_durability(const TDurability::type val);

  void __set_cellVisibility(const TCellVisibility& val);

  void __set_returnResults(const bool val);

  bool operator == (const TIncrement & rhs) const
  {
    if (!(row == rhs.row))
      return false;
    if (!(columns == rhs.columns))
      return false;
    if (__isset.attributes != rhs.__isset.attributes)
      return false;
    else if (__isset.attributes && !(attributes == rhs.attributes))
      return false;
    if (__isset.durability != rhs.__isset.durability)
      return false;
    else if (__isset.durability && !(durability == rhs.durability))
      return false;
    if (__isset.cellVisibility != rhs.__isset.cellVisibility)
      return false;
    else if (__isset.cellVisibility && !(cellVisibility == rhs.cellVisibility))
      return false;
    if (__isset.returnResults != rhs.__isset.returnResults)
      return false;
    else if (__isset.returnResults && !(returnResults == rhs.returnResults))
      return false;
    return true;
  }
  bool operator != (const TIncrement &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TIncrement & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const TIncrement& obj);
};

void swap(TIncrement &a, TIncrement &b);

typedef struct _TAppend__isset {
  _TAppend__isset() : attributes(false), durability(false), cellVisibility(false), returnResults(false) {}
  bool attributes :1;
  bool durability :1;
  bool cellVisibility :1;
  bool returnResults :1;
} _TAppend__isset;

class TAppend {
 public:

  static const char* ascii_fingerprint; // = "75772F463E7AB576E9AD8BC91682AC12";
  static const uint8_t binary_fingerprint[16]; // = {0x75,0x77,0x2F,0x46,0x3E,0x7A,0xB5,0x76,0xE9,0xAD,0x8B,0xC9,0x16,0x82,0xAC,0x12};

  TAppend(const TAppend&);
  TAppend& operator=(const TAppend&);
  TAppend() : row(), durability((TDurability::type)0), returnResults(0) {
  }

  virtual ~TAppend() throw();
  std::string row;
  std::vector<TColumnValue>  columns;
  std::map<std::string, std::string>  attributes;
  TDurability::type durability;
  TCellVisibility cellVisibility;
  bool returnResults;

  _TAppend__isset __isset;

  void __set_row(const std::string& val);

  void __set_columns(const std::vector<TColumnValue> & val);

  void __set_attributes(const std::map<std::string, std::string> & val);

  void __set_durability(const TDurability::type val);

  void __set_cellVisibility(const TCellVisibility& val);

  void __set_returnResults(const bool val);

  bool operator == (const TAppend & rhs) const
  {
    if (!(row == rhs.row))
      return false;
    if (!(columns == rhs.columns))
      return false;
    if (__isset.attributes != rhs.__isset.attributes)
      return false;
    else if (__isset.attributes && !(attributes == rhs.attributes))
      return false;
    if (__isset.durability != rhs.__isset.durability)
      return false;
    else if (__isset.durability && !(durability == rhs.durability))
      return false;
    if (__isset.cellVisibility != rhs.__isset.cellVisibility)
      return false;
    else if (__isset.cellVisibility && !(cellVisibility == rhs.cellVisibility))
      return false;
    if (__isset.returnResults != rhs.__isset.returnResults)
      return false;
    else if (__isset.returnResults && !(returnResults == rhs.returnResults))
      return false;
    return true;
  }
  bool operator != (const TAppend &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TAppend & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const TAppend& obj);
};

void swap(TAppend &a, TAppend &b);

typedef struct _TScan__isset {
  _TScan__isset() : startRow(false), stopRow(false), columns(false), caching(false), maxVersions(true), timeRange(false), filterString(false), batchSize(false), attributes(false), authorizations(false), reversed(false), cacheBlocks(false), colFamTimeRangeMap(false), readType(false), limit(false), consistency(false), targetReplicaId(false), filterBytes(false) {}
  bool startRow :1;
  bool stopRow :1;
  bool columns :1;
  bool caching :1;
  bool maxVersions :1;
  bool timeRange :1;
  bool filterString :1;
  bool batchSize :1;
  bool attributes :1;
  bool authorizations :1;
  bool reversed :1;
  bool cacheBlocks :1;
  bool colFamTimeRangeMap :1;
  bool readType :1;
  bool limit :1;
  bool consistency :1;
  bool targetReplicaId :1;
  bool filterBytes :1;
} _TScan__isset;

class TScan {
 public:

  static const char* ascii_fingerprint; // = "C0FB8D6E398D5441FD662A767A674E71";
  static const uint8_t binary_fingerprint[16]; // = {0xC0,0xFB,0x8D,0x6E,0x39,0x8D,0x54,0x41,0xFD,0x66,0x2A,0x76,0x7A,0x67,0x4E,0x71};

  TScan(const TScan&);
  TScan& operator=(const TScan&);
  TScan() : startRow(), stopRow(), caching(0), maxVersions(1), filterString(), batchSize(0), reversed(0), cacheBlocks(0), readType((TReadType::type)0), limit(0), consistency((TConsistency::type)0), targetReplicaId(0), filterBytes() {
  }

  virtual ~TScan() throw();
  std::string startRow;
  std::string stopRow;
  std::vector<TColumn>  columns;
  int32_t caching;
  int32_t maxVersions;
  TTimeRange timeRange;
  std::string filterString;
  int32_t batchSize;
  std::map<std::string, std::string>  attributes;
  TAuthorization authorizations;
  bool reversed;
  bool cacheBlocks;
  std::map<std::string, TTimeRange>  colFamTimeRangeMap;
  TReadType::type readType;
  int32_t limit;
  TConsistency::type consistency;
  int32_t targetReplicaId;
  std::string filterBytes;

  _TScan__isset __isset;

  void __set_startRow(const std::string& val);

  void __set_stopRow(const std::string& val);

  void __set_columns(const std::vector<TColumn> & val);

  void __set_caching(const int32_t val);

  void __set_maxVersions(const int32_t val);

  void __set_timeRange(const TTimeRange& val);

  void __set_filterString(const std::string& val);

  void __set_batchSize(const int32_t val);

  void __set_attributes(const std::map<std::string, std::string> & val);

  void __set_authorizations(const TAuthorization& val);

  void __set_reversed(const bool val);

  void __set_cacheBlocks(const bool val);

  void __set_colFamTimeRangeMap(const std::map<std::string, TTimeRange> & val);

  void __set_readType(const TReadType::type val);

  void __set_limit(const int32_t val);

  void __set_consistency(const TConsistency::type val);

  void __set_targetReplicaId(const int32_t val);

  void __set_filterBytes(const std::string& val);

  bool operator == (const TScan & rhs) const
  {
    if (__isset.startRow != rhs.__isset.startRow)
      return false;
    else if (__isset.startRow && !(startRow == rhs.startRow))
      return false;
    if (__isset.stopRow != rhs.__isset.stopRow)
      return false;
    else if (__isset.stopRow && !(stopRow == rhs.stopRow))
      return false;
    if (__isset.columns != rhs.__isset.columns)
      return false;
    else if (__isset.columns && !(columns == rhs.columns))
      return false;
    if (__isset.caching != rhs.__isset.caching)
      return false;
    else if (__isset.caching && !(caching == rhs.caching))
      return false;
    if (__isset.maxVersions != rhs.__isset.maxVersions)
      return false;
    else if (__isset.maxVersions && !(maxVersions == rhs.maxVersions))
      return false;
    if (__isset.timeRange != rhs.__isset.timeRange)
      return false;
    else if (__isset.timeRange && !(timeRange == rhs.timeRange))
      return false;
    if (__isset.filterString != rhs.__isset.filterString)
      return false;
    else if (__isset.filterString && !(filterString == rhs.filterString))
      return false;
    if (__isset.batchSize != rhs.__isset.batchSize)
      return false;
    else if (__isset.batchSize && !(batchSize == rhs.batchSize))
      return false;
    if (__isset.attributes != rhs.__isset.attributes)
      return false;
    else if (__isset.attributes && !(attributes == rhs.attributes))
      return false;
    if (__isset.authorizations != rhs.__isset.authorizations)
      return false;
    else if (__isset.authorizations && !(authorizations == rhs.authorizations))
      return false;
    if (__isset.reversed != rhs.__isset.reversed)
      return false;
    else if (__isset.reversed && !(reversed == rhs.reversed))
      return false;
    if (__isset.cacheBlocks != rhs.__isset.cacheBlocks)
      return false;
    else if (__isset.cacheBlocks && !(cacheBlocks == rhs.cacheBlocks))
      return false;
    if (__isset.colFamTimeRangeMap != rhs.__isset.colFamTimeRangeMap)
      return false;
    else if (__isset.colFamTimeRangeMap && !(colFamTimeRangeMap == rhs.colFamTimeRangeMap))
      return false;
    if (__isset.readType != rhs.__isset.readType)
      return false;
    else if (__isset.readType && !(readType == rhs.readType))
      return false;
    if (__isset.limit != rhs.__isset.limit)
      return false;
    else if (__isset.limit && !(limit == rhs.limit))
      return false;
    if (__isset.consistency != rhs.__isset.consistency)
      return false;
    else if (__isset.consistency && !(consistency == rhs.consistency))
      return false;
    if (__isset.targetReplicaId != rhs.__isset.targetReplicaId)
      return false;
    else if (__isset.targetReplicaId && !(targetReplicaId == rhs.targetReplicaId))
      return false;
    if (__isset.filterBytes != rhs.__isset.filterBytes)
      return false;
    else if (__isset.filterBytes && !(filterBytes == rhs.filterBytes))
      return false;
    return true;
  }
  bool operator != (const TScan &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TScan & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const TScan& obj);
};

void swap(TScan &a, TScan &b);

typedef struct _TMutation__isset {
  _TMutation__isset() : put(false), deleteSingle(false) {}
  bool put :1;
  bool deleteSingle :1;
} _TMutation__isset;

class TMutation {
 public:

  static const char* ascii_fingerprint; // = "46F3F4C6EC40992BBE15FA270D6ADEF5";
  static const uint8_t binary_fingerprint[16]; // = {0x46,0xF3,0xF4,0xC6,0xEC,0x40,0x99,0x2B,0xBE,0x15,0xFA,0x27,0x0D,0x6A,0xDE,0xF5};

  TMutation(const TMutation&);
  TMutation& operator=(const TMutation&);
  TMutation() {
  }

  virtual ~TMutation() throw();
  TPut put;
  TDelete deleteSingle;

  _TMutation__isset __isset;

  void __set_put(const TPut& val);

  void __set_deleteSingle(const TDelete& val);

  bool operator == (const TMutation & rhs) const
  {
    if (!(put == rhs.put))
      return false;
    if (!(deleteSingle == rhs.deleteSingle))
      return false;
    return true;
  }
  bool operator != (const TMutation &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TMutation & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const TMutation& obj);
};

void swap(TMutation &a, TMutation &b);


class TRowMutations {
 public:

  static const char* ascii_fingerprint; // = "EB68318A0931133A26AA17B748D52040";
  static const uint8_t binary_fingerprint[16]; // = {0xEB,0x68,0x31,0x8A,0x09,0x31,0x13,0x3A,0x26,0xAA,0x17,0xB7,0x48,0xD5,0x20,0x40};

  TRowMutations(const TRowMutations&);
  TRowMutations& operator=(const TRowMutations&);
  TRowMutations() : row() {
  }

  virtual ~TRowMutations() throw();
  std::string row;
  std::vector<TMutation>  mutations;

  void __set_row(const std::string& val);

  void __set_mutations(const std::vector<TMutation> & val);

  bool operator == (const TRowMutations & rhs) const
  {
    if (!(row == rhs.row))
      return false;
    if (!(mutations == rhs.mutations))
      return false;
    return true;
  }
  bool operator != (const TRowMutations &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TRowMutations & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const TRowMutations& obj);
};

void swap(TRowMutations &a, TRowMutations &b);

typedef struct _THRegionInfo__isset {
  _THRegionInfo__isset() : startKey(false), endKey(false), offline(false), split(false), replicaId(false) {}
  bool startKey :1;
  bool endKey :1;
  bool offline :1;
  bool split :1;
  bool replicaId :1;
} _THRegionInfo__isset;

class THRegionInfo {
 public:

  static const char* ascii_fingerprint; // = "E29D5A124268D48991C782591956E9C4";
  static const uint8_t binary_fingerprint[16]; // = {0xE2,0x9D,0x5A,0x12,0x42,0x68,0xD4,0x89,0x91,0xC7,0x82,0x59,0x19,0x56,0xE9,0xC4};

  THRegionInfo(const THRegionInfo&);
  THRegionInfo& operator=(const THRegionInfo&);
  THRegionInfo() : regionId(0), tableName(), startKey(), endKey(), offline(0), split(0), replicaId(0) {
  }

  virtual ~THRegionInfo() throw();
  int64_t regionId;
  std::string tableName;
  std::string startKey;
  std::string endKey;
  bool offline;
  bool split;
  int32_t replicaId;

  _THRegionInfo__isset __isset;

  void __set_regionId(const int64_t val);

  void __set_tableName(const std::string& val);

  void __set_startKey(const std::string& val);

  void __set_endKey(const std::string& val);

  void __set_offline(const bool val);

  void __set_split(const bool val);

  void __set_replicaId(const int32_t val);

  bool operator == (const THRegionInfo & rhs) const
  {
    if (!(regionId == rhs.regionId))
      return false;
    if (!(tableName == rhs.tableName))
      return false;
    if (__isset.startKey != rhs.__isset.startKey)
      return false;
    else if (__isset.startKey && !(startKey == rhs.startKey))
      return false;
    if (__isset.endKey != rhs.__isset.endKey)
      return false;
    else if (__isset.endKey && !(endKey == rhs.endKey))
      return false;
    if (__isset.offline != rhs.__isset.offline)
      return false;
    else if (__isset.offline && !(offline == rhs.offline))
      return false;
    if (__isset.split != rhs.__isset.split)
      return false;
    else if (__isset.split && !(split == rhs.split))
      return false;
    if (__isset.replicaId != rhs.__isset.replicaId)
      return false;
    else if (__isset.replicaId && !(replicaId == rhs.replicaId))
      return false;
    return true;
  }
  bool operator != (const THRegionInfo &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const THRegionInfo & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const THRegionInfo& obj);
};

void swap(THRegionInfo &a, THRegionInfo &b);

typedef struct _TServerName__isset {
  _TServerName__isset() : port(false), startCode(false) {}
  bool port :1;
  bool startCode :1;
} _TServerName__isset;

class TServerName {
 public:

  static const char* ascii_fingerprint; // = "382A5014141BA5C913BB4175A5B43756";
  static const uint8_t binary_fingerprint[16]; // = {0x38,0x2A,0x50,0x14,0x14,0x1B,0xA5,0xC9,0x13,0xBB,0x41,0x75,0xA5,0xB4,0x37,0x56};

  TServerName(const TServerName&);
  TServerName& operator=(const TServerName&);
  TServerName() : hostName(), port(0), startCode(0) {
  }

  virtual ~TServerName() throw();
  std::string hostName;
  int32_t port;
  int64_t startCode;

  _TServerName__isset __isset;

  void __set_hostName(const std::string& val);

  void __set_port(const int32_t val);

  void __set_startCode(const int64_t val);

  bool operator == (const TServerName & rhs) const
  {
    if (!(hostName == rhs.hostName))
      return false;
    if (__isset.port != rhs.__isset.port)
      return false;
    else if (__isset.port && !(port == rhs.port))
      return false;
    if (__isset.startCode != rhs.__isset.startCode)
      return false;
    else if (__isset.startCode && !(startCode == rhs.startCode))
      return false;
    return true;
  }
  bool operator != (const TServerName &rhs) const {
    return !(*this == rhs);
  }
    bool operator<(const TServerName &rhs) const { return startCode < rhs.startCode; };
  // bool operator < (const TServerName & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const TServerName& obj);
};

void swap(TServerName &a, TServerName &b);


class THRegionLocation {
 public:

  static const char* ascii_fingerprint; // = "95ADA83616D80A12727CC523B6EFC295";
  static const uint8_t binary_fingerprint[16]; // = {0x95,0xAD,0xA8,0x36,0x16,0xD8,0x0A,0x12,0x72,0x7C,0xC5,0x23,0xB6,0xEF,0xC2,0x95};

  THRegionLocation(const THRegionLocation&);
  THRegionLocation& operator=(const THRegionLocation&);
  THRegionLocation() {
  }

  virtual ~THRegionLocation() throw();
  TServerName serverName;
  THRegionInfo regionInfo;

  void __set_serverName(const TServerName& val);

  void __set_regionInfo(const THRegionInfo& val);

  bool operator == (const THRegionLocation & rhs) const
  {
    if (!(serverName == rhs.serverName))
      return false;
    if (!(regionInfo == rhs.regionInfo))
      return false;
    return true;
  }
  bool operator != (const THRegionLocation &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const THRegionLocation & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const THRegionLocation& obj);
};

void swap(THRegionLocation &a, THRegionLocation &b);

typedef struct _TTableName__isset {
  _TTableName__isset() : ns(false) {}
  bool ns :1;
} _TTableName__isset;

class TTableName {
 public:

  static const char* ascii_fingerprint; // = "383E55F0D02199A3E52B9227E13A83A2";
  static const uint8_t binary_fingerprint[16]; // = {0x38,0x3E,0x55,0xF0,0xD0,0x21,0x99,0xA3,0xE5,0x2B,0x92,0x27,0xE1,0x3A,0x83,0xA2};

  TTableName(const TTableName&);
  TTableName& operator=(const TTableName&);
  TTableName() : ns(), qualifier() {
  }

  virtual ~TTableName() throw();
  std::string ns;
  std::string qualifier;

  _TTableName__isset __isset;

  void __set_ns(const std::string& val);

  void __set_qualifier(const std::string& val);

  bool operator == (const TTableName & rhs) const
  {
    if (__isset.ns != rhs.__isset.ns)
      return false;
    else if (__isset.ns && !(ns == rhs.ns))
      return false;
    if (!(qualifier == rhs.qualifier))
      return false;
    return true;
  }
  bool operator != (const TTableName &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TTableName & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const TTableName& obj);
};

void swap(TTableName &a, TTableName &b);

typedef struct _TColumnFamilyDescriptor__isset {
  _TColumnFamilyDescriptor__isset() : attributes(false), configuration(false), blockSize(false), bloomnFilterType(false), compressionType(false), dfsReplication(false), dataBlockEncoding(false), keepDeletedCells(false), maxVersions(false), minVersions(false), scope(false), timeToLive(false), blockCacheEnabled(false), cacheBloomsOnWrite(false), cacheDataOnWrite(false), cacheIndexesOnWrite(false), compressTags(false), evictBlocksOnClose(false), inMemory(false) {}
  bool attributes :1;
  bool configuration :1;
  bool blockSize :1;
  bool bloomnFilterType :1;
  bool compressionType :1;
  bool dfsReplication :1;
  bool dataBlockEncoding :1;
  bool keepDeletedCells :1;
  bool maxVersions :1;
  bool minVersions :1;
  bool scope :1;
  bool timeToLive :1;
  bool blockCacheEnabled :1;
  bool cacheBloomsOnWrite :1;
  bool cacheDataOnWrite :1;
  bool cacheIndexesOnWrite :1;
  bool compressTags :1;
  bool evictBlocksOnClose :1;
  bool inMemory :1;
} _TColumnFamilyDescriptor__isset;

class TColumnFamilyDescriptor {
 public:

  static const char* ascii_fingerprint; // = "0F1C03437C0BD5DB39B166A225239E5F";
  static const uint8_t binary_fingerprint[16]; // = {0x0F,0x1C,0x03,0x43,0x7C,0x0B,0xD5,0xDB,0x39,0xB1,0x66,0xA2,0x25,0x23,0x9E,0x5F};

  TColumnFamilyDescriptor(const TColumnFamilyDescriptor&);
  TColumnFamilyDescriptor& operator=(const TColumnFamilyDescriptor&);
  TColumnFamilyDescriptor() : name(), blockSize(0), bloomnFilterType((TBloomFilterType::type)0), compressionType((TCompressionAlgorithm::type)0), dfsReplication(0), dataBlockEncoding((TDataBlockEncoding::type)0), keepDeletedCells((TKeepDeletedCells::type)0), maxVersions(0), minVersions(0), scope(0), timeToLive(0), blockCacheEnabled(0), cacheBloomsOnWrite(0), cacheDataOnWrite(0), cacheIndexesOnWrite(0), compressTags(0), evictBlocksOnClose(0), inMemory(0) {
  }

  virtual ~TColumnFamilyDescriptor() throw();
  std::string name;
  std::map<std::string, std::string>  attributes;
  std::map<std::string, std::string>  configuration;
  int32_t blockSize;
  TBloomFilterType::type bloomnFilterType;
  TCompressionAlgorithm::type compressionType;
  int16_t dfsReplication;
  TDataBlockEncoding::type dataBlockEncoding;
  TKeepDeletedCells::type keepDeletedCells;
  int32_t maxVersions;
  int32_t minVersions;
  int32_t scope;
  int32_t timeToLive;
  bool blockCacheEnabled;
  bool cacheBloomsOnWrite;
  bool cacheDataOnWrite;
  bool cacheIndexesOnWrite;
  bool compressTags;
  bool evictBlocksOnClose;
  bool inMemory;

  _TColumnFamilyDescriptor__isset __isset;

  void __set_name(const std::string& val);

  void __set_attributes(const std::map<std::string, std::string> & val);

  void __set_configuration(const std::map<std::string, std::string> & val);

  void __set_blockSize(const int32_t val);

  void __set_bloomnFilterType(const TBloomFilterType::type val);

  void __set_compressionType(const TCompressionAlgorithm::type val);

  void __set_dfsReplication(const int16_t val);

  void __set_dataBlockEncoding(const TDataBlockEncoding::type val);

  void __set_keepDeletedCells(const TKeepDeletedCells::type val);

  void __set_maxVersions(const int32_t val);

  void __set_minVersions(const int32_t val);

  void __set_scope(const int32_t val);

  void __set_timeToLive(const int32_t val);

  void __set_blockCacheEnabled(const bool val);

  void __set_cacheBloomsOnWrite(const bool val);

  void __set_cacheDataOnWrite(const bool val);

  void __set_cacheIndexesOnWrite(const bool val);

  void __set_compressTags(const bool val);

  void __set_evictBlocksOnClose(const bool val);

  void __set_inMemory(const bool val);

  bool operator == (const TColumnFamilyDescriptor & rhs) const
  {
    if (!(name == rhs.name))
      return false;
    if (__isset.attributes != rhs.__isset.attributes)
      return false;
    else if (__isset.attributes && !(attributes == rhs.attributes))
      return false;
    if (__isset.configuration != rhs.__isset.configuration)
      return false;
    else if (__isset.configuration && !(configuration == rhs.configuration))
      return false;
    if (__isset.blockSize != rhs.__isset.blockSize)
      return false;
    else if (__isset.blockSize && !(blockSize == rhs.blockSize))
      return false;
    if (__isset.bloomnFilterType != rhs.__isset.bloomnFilterType)
      return false;
    else if (__isset.bloomnFilterType && !(bloomnFilterType == rhs.bloomnFilterType))
      return false;
    if (__isset.compressionType != rhs.__isset.compressionType)
      return false;
    else if (__isset.compressionType && !(compressionType == rhs.compressionType))
      return false;
    if (__isset.dfsReplication != rhs.__isset.dfsReplication)
      return false;
    else if (__isset.dfsReplication && !(dfsReplication == rhs.dfsReplication))
      return false;
    if (__isset.dataBlockEncoding != rhs.__isset.dataBlockEncoding)
      return false;
    else if (__isset.dataBlockEncoding && !(dataBlockEncoding == rhs.dataBlockEncoding))
      return false;
    if (__isset.keepDeletedCells != rhs.__isset.keepDeletedCells)
      return false;
    else if (__isset.keepDeletedCells && !(keepDeletedCells == rhs.keepDeletedCells))
      return false;
    if (__isset.maxVersions != rhs.__isset.maxVersions)
      return false;
    else if (__isset.maxVersions && !(maxVersions == rhs.maxVersions))
      return false;
    if (__isset.minVersions != rhs.__isset.minVersions)
      return false;
    else if (__isset.minVersions && !(minVersions == rhs.minVersions))
      return false;
    if (__isset.scope != rhs.__isset.scope)
      return false;
    else if (__isset.scope && !(scope == rhs.scope))
      return false;
    if (__isset.timeToLive != rhs.__isset.timeToLive)
      return false;
    else if (__isset.timeToLive && !(timeToLive == rhs.timeToLive))
      return false;
    if (__isset.blockCacheEnabled != rhs.__isset.blockCacheEnabled)
      return false;
    else if (__isset.blockCacheEnabled && !(blockCacheEnabled == rhs.blockCacheEnabled))
      return false;
    if (__isset.cacheBloomsOnWrite != rhs.__isset.cacheBloomsOnWrite)
      return false;
    else if (__isset.cacheBloomsOnWrite && !(cacheBloomsOnWrite == rhs.cacheBloomsOnWrite))
      return false;
    if (__isset.cacheDataOnWrite != rhs.__isset.cacheDataOnWrite)
      return false;
    else if (__isset.cacheDataOnWrite && !(cacheDataOnWrite == rhs.cacheDataOnWrite))
      return false;
    if (__isset.cacheIndexesOnWrite != rhs.__isset.cacheIndexesOnWrite)
      return false;
    else if (__isset.cacheIndexesOnWrite && !(cacheIndexesOnWrite == rhs.cacheIndexesOnWrite))
      return false;
    if (__isset.compressTags != rhs.__isset.compressTags)
      return false;
    else if (__isset.compressTags && !(compressTags == rhs.compressTags))
      return false;
    if (__isset.evictBlocksOnClose != rhs.__isset.evictBlocksOnClose)
      return false;
    else if (__isset.evictBlocksOnClose && !(evictBlocksOnClose == rhs.evictBlocksOnClose))
      return false;
    if (__isset.inMemory != rhs.__isset.inMemory)
      return false;
    else if (__isset.inMemory && !(inMemory == rhs.inMemory))
      return false;
    return true;
  }
  bool operator != (const TColumnFamilyDescriptor &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TColumnFamilyDescriptor & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const TColumnFamilyDescriptor& obj);
};

void swap(TColumnFamilyDescriptor &a, TColumnFamilyDescriptor &b);

typedef struct _TTableDescriptor__isset {
  _TTableDescriptor__isset() : columns(false), attributes(false), durability(false) {}
  bool columns :1;
  bool attributes :1;
  bool durability :1;
} _TTableDescriptor__isset;

class TTableDescriptor {
 public:

  static const char* ascii_fingerprint; // = "5259225B567357D5D97128B4CCDF5169";
  static const uint8_t binary_fingerprint[16]; // = {0x52,0x59,0x22,0x5B,0x56,0x73,0x57,0xD5,0xD9,0x71,0x28,0xB4,0xCC,0xDF,0x51,0x69};

  TTableDescriptor(const TTableDescriptor&);
  TTableDescriptor& operator=(const TTableDescriptor&);
  TTableDescriptor() : durability((TDurability::type)0) {
  }

  virtual ~TTableDescriptor() throw();
  TTableName tableName;
  std::vector<TColumnFamilyDescriptor>  columns;
  std::map<std::string, std::string>  attributes;
  TDurability::type durability;

  _TTableDescriptor__isset __isset;

  void __set_tableName(const TTableName& val);

  void __set_columns(const std::vector<TColumnFamilyDescriptor> & val);

  void __set_attributes(const std::map<std::string, std::string> & val);

  void __set_durability(const TDurability::type val);

  bool operator == (const TTableDescriptor & rhs) const
  {
    if (!(tableName == rhs.tableName))
      return false;
    if (__isset.columns != rhs.__isset.columns)
      return false;
    else if (__isset.columns && !(columns == rhs.columns))
      return false;
    if (__isset.attributes != rhs.__isset.attributes)
      return false;
    else if (__isset.attributes && !(attributes == rhs.attributes))
      return false;
    if (__isset.durability != rhs.__isset.durability)
      return false;
    else if (__isset.durability && !(durability == rhs.durability))
      return false;
    return true;
  }
  bool operator != (const TTableDescriptor &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TTableDescriptor & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const TTableDescriptor& obj);
};

void swap(TTableDescriptor &a, TTableDescriptor &b);

typedef struct _TNamespaceDescriptor__isset {
  _TNamespaceDescriptor__isset() : configuration(false) {}
  bool configuration :1;
} _TNamespaceDescriptor__isset;

class TNamespaceDescriptor {
 public:

  static const char* ascii_fingerprint; // = "31FBBEA1FC165CE500F2DE705C5C27CE";
  static const uint8_t binary_fingerprint[16]; // = {0x31,0xFB,0xBE,0xA1,0xFC,0x16,0x5C,0xE5,0x00,0xF2,0xDE,0x70,0x5C,0x5C,0x27,0xCE};

  TNamespaceDescriptor(const TNamespaceDescriptor&);
  TNamespaceDescriptor& operator=(const TNamespaceDescriptor&);
  TNamespaceDescriptor() : name() {
  }

  virtual ~TNamespaceDescriptor() throw();
  std::string name;
  std::map<std::string, std::string>  configuration;

  _TNamespaceDescriptor__isset __isset;

  void __set_name(const std::string& val);

  void __set_configuration(const std::map<std::string, std::string> & val);

  bool operator == (const TNamespaceDescriptor & rhs) const
  {
    if (!(name == rhs.name))
      return false;
    if (__isset.configuration != rhs.__isset.configuration)
      return false;
    else if (__isset.configuration && !(configuration == rhs.configuration))
      return false;
    return true;
  }
  bool operator != (const TNamespaceDescriptor &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TNamespaceDescriptor & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const TNamespaceDescriptor& obj);
};

void swap(TNamespaceDescriptor &a, TNamespaceDescriptor &b);

typedef struct _TLogQueryFilter__isset {
  _TLogQueryFilter__isset() : regionName(false), clientAddress(false), tableName(false), userName(false), limit(true), logType(true), filterByOperator(true) {}
  bool regionName :1;
  bool clientAddress :1;
  bool tableName :1;
  bool userName :1;
  bool limit :1;
  bool logType :1;
  bool filterByOperator :1;
} _TLogQueryFilter__isset;

class TLogQueryFilter {
 public:

  static const char* ascii_fingerprint; // = "76D4A6CC4FBEF0BF5B09853ED97160E9";
  static const uint8_t binary_fingerprint[16]; // = {0x76,0xD4,0xA6,0xCC,0x4F,0xBE,0xF0,0xBF,0x5B,0x09,0x85,0x3E,0xD9,0x71,0x60,0xE9};

  TLogQueryFilter(const TLogQueryFilter&);
  TLogQueryFilter& operator=(const TLogQueryFilter&);
  TLogQueryFilter() : regionName(), clientAddress(), tableName(), userName(), limit(10), logType((TLogType::type)1), filterByOperator((TFilterByOperator::type)1) {
    logType = (TLogType::type)1;

    filterByOperator = (TFilterByOperator::type)1;

  }

  virtual ~TLogQueryFilter() throw();
  std::string regionName;
  std::string clientAddress;
  std::string tableName;
  std::string userName;
  int32_t limit;
  TLogType::type logType;
  TFilterByOperator::type filterByOperator;

  _TLogQueryFilter__isset __isset;

  void __set_regionName(const std::string& val);

  void __set_clientAddress(const std::string& val);

  void __set_tableName(const std::string& val);

  void __set_userName(const std::string& val);

  void __set_limit(const int32_t val);

  void __set_logType(const TLogType::type val);

  void __set_filterByOperator(const TFilterByOperator::type val);

  bool operator == (const TLogQueryFilter & rhs) const
  {
    if (__isset.regionName != rhs.__isset.regionName)
      return false;
    else if (__isset.regionName && !(regionName == rhs.regionName))
      return false;
    if (__isset.clientAddress != rhs.__isset.clientAddress)
      return false;
    else if (__isset.clientAddress && !(clientAddress == rhs.clientAddress))
      return false;
    if (__isset.tableName != rhs.__isset.tableName)
      return false;
    else if (__isset.tableName && !(tableName == rhs.tableName))
      return false;
    if (__isset.userName != rhs.__isset.userName)
      return false;
    else if (__isset.userName && !(userName == rhs.userName))
      return false;
    if (__isset.limit != rhs.__isset.limit)
      return false;
    else if (__isset.limit && !(limit == rhs.limit))
      return false;
    if (__isset.logType != rhs.__isset.logType)
      return false;
    else if (__isset.logType && !(logType == rhs.logType))
      return false;
    if (__isset.filterByOperator != rhs.__isset.filterByOperator)
      return false;
    else if (__isset.filterByOperator && !(filterByOperator == rhs.filterByOperator))
      return false;
    return true;
  }
  bool operator != (const TLogQueryFilter &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TLogQueryFilter & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const TLogQueryFilter& obj);
};

void swap(TLogQueryFilter &a, TLogQueryFilter &b);

typedef struct _TOnlineLogRecord__isset {
  _TOnlineLogRecord__isset() : regionName(false) {}
  bool regionName :1;
} _TOnlineLogRecord__isset;

class TOnlineLogRecord {
 public:

  static const char* ascii_fingerprint; // = "04CC55DC4A0AC369E51739AC731025D8";
  static const uint8_t binary_fingerprint[16]; // = {0x04,0xCC,0x55,0xDC,0x4A,0x0A,0xC3,0x69,0xE5,0x17,0x39,0xAC,0x73,0x10,0x25,0xD8};

  TOnlineLogRecord(const TOnlineLogRecord&);
  TOnlineLogRecord& operator=(const TOnlineLogRecord&);
  TOnlineLogRecord() : startTime(0), processingTime(0), queueTime(0), responseSize(0), clientAddress(), serverClass(), methodName(), callDetails(), param(), userName(), multiGetsCount(0), multiMutationsCount(0), multiServiceCalls(0), regionName() {
  }

  virtual ~TOnlineLogRecord() throw();
  int64_t startTime;
  int32_t processingTime;
  int32_t queueTime;
  int64_t responseSize;
  std::string clientAddress;
  std::string serverClass;
  std::string methodName;
  std::string callDetails;
  std::string param;
  std::string userName;
  int32_t multiGetsCount;
  int32_t multiMutationsCount;
  int32_t multiServiceCalls;
  std::string regionName;

  _TOnlineLogRecord__isset __isset;

  void __set_startTime(const int64_t val);

  void __set_processingTime(const int32_t val);

  void __set_queueTime(const int32_t val);

  void __set_responseSize(const int64_t val);

  void __set_clientAddress(const std::string& val);

  void __set_serverClass(const std::string& val);

  void __set_methodName(const std::string& val);

  void __set_callDetails(const std::string& val);

  void __set_param(const std::string& val);

  void __set_userName(const std::string& val);

  void __set_multiGetsCount(const int32_t val);

  void __set_multiMutationsCount(const int32_t val);

  void __set_multiServiceCalls(const int32_t val);

  void __set_regionName(const std::string& val);

  bool operator == (const TOnlineLogRecord & rhs) const
  {
    if (!(startTime == rhs.startTime))
      return false;
    if (!(processingTime == rhs.processingTime))
      return false;
    if (!(queueTime == rhs.queueTime))
      return false;
    if (!(responseSize == rhs.responseSize))
      return false;
    if (!(clientAddress == rhs.clientAddress))
      return false;
    if (!(serverClass == rhs.serverClass))
      return false;
    if (!(methodName == rhs.methodName))
      return false;
    if (!(callDetails == rhs.callDetails))
      return false;
    if (!(param == rhs.param))
      return false;
    if (!(userName == rhs.userName))
      return false;
    if (!(multiGetsCount == rhs.multiGetsCount))
      return false;
    if (!(multiMutationsCount == rhs.multiMutationsCount))
      return false;
    if (!(multiServiceCalls == rhs.multiServiceCalls))
      return false;
    if (__isset.regionName != rhs.__isset.regionName)
      return false;
    else if (__isset.regionName && !(regionName == rhs.regionName))
      return false;
    return true;
  }
  bool operator != (const TOnlineLogRecord &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TOnlineLogRecord & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const TOnlineLogRecord& obj);
};

void swap(TOnlineLogRecord &a, TOnlineLogRecord &b);

typedef struct _TIOError__isset {
  _TIOError__isset() : message(false), canRetry(false) {}
  bool message :1;
  bool canRetry :1;
} _TIOError__isset;

class TIOError : public ::apache::thrift::TException {
 public:

  static const char* ascii_fingerprint; // = "6200BB33D161C25E4ABCC4E5B0FB2883";
  static const uint8_t binary_fingerprint[16]; // = {0x62,0x00,0xBB,0x33,0xD1,0x61,0xC2,0x5E,0x4A,0xBC,0xC4,0xE5,0xB0,0xFB,0x28,0x83};

  TIOError(const TIOError&);
  TIOError& operator=(const TIOError&);
  TIOError() : message(), canRetry(0) {
  }

  virtual ~TIOError() throw();
  std::string message;
  bool canRetry;

  _TIOError__isset __isset;

  void __set_message(const std::string& val);

  void __set_canRetry(const bool val);

  bool operator == (const TIOError & rhs) const
  {
    if (__isset.message != rhs.__isset.message)
      return false;
    else if (__isset.message && !(message == rhs.message))
      return false;
    if (__isset.canRetry != rhs.__isset.canRetry)
      return false;
    else if (__isset.canRetry && !(canRetry == rhs.canRetry))
      return false;
    return true;
  }
  bool operator != (const TIOError &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TIOError & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const TIOError& obj);
};

void swap(TIOError &a, TIOError &b);

typedef struct _TIllegalArgument__isset {
  _TIllegalArgument__isset() : message(false) {}
  bool message :1;
} _TIllegalArgument__isset;

class TIllegalArgument : public ::apache::thrift::TException {
 public:

  static const char* ascii_fingerprint; // = "66E694018C17E5B65A59AE8F55CCA3CD";
  static const uint8_t binary_fingerprint[16]; // = {0x66,0xE6,0x94,0x01,0x8C,0x17,0xE5,0xB6,0x5A,0x59,0xAE,0x8F,0x55,0xCC,0xA3,0xCD};

  TIllegalArgument(const TIllegalArgument&);
  TIllegalArgument& operator=(const TIllegalArgument&);
  TIllegalArgument() : message() {
  }

  virtual ~TIllegalArgument() throw();
  std::string message;

  _TIllegalArgument__isset __isset;

  void __set_message(const std::string& val);

  bool operator == (const TIllegalArgument & rhs) const
  {
    if (__isset.message != rhs.__isset.message)
      return false;
    else if (__isset.message && !(message == rhs.message))
      return false;
    return true;
  }
  bool operator != (const TIllegalArgument &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TIllegalArgument & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const TIllegalArgument& obj);
};

void swap(TIllegalArgument &a, TIllegalArgument &b);

}}}} // namespace

#endif
